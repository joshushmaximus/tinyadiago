<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Pracplay.Prac.Core</name>
    </assembly>
    <members>
        <member name="T:Prac.Core.HistSimMemory">
            <summary>
            loads and plays back simulations in memory for faster playback
            </summary>
        </member>
        <member name="T:Prac.Core.HistSimIndexPlay">
            <summary>
            playback a historical simulation from an index
            </summary>
        </member>
        <member name="M:Prac.Core.HistSimIndexPlay.PlayTo(System.Int64)">
            <summary>
            play simulation until specified day/time is hit
            </summary>
            <param name="datetime"></param>
        </member>
        <member name="M:Prac.Core.HistSimIndexPlay.Initialize">
            <summary>
            initialize simulation (will be initilized automatically when calling playto)
            </summary>
        </member>
        <member name="M:Prac.Core.HistSimIndexPlay.Stop">
            <summary>
            stop simulation if presently running
            </summary>
        </member>
        <member name="M:Prac.Core.HistSimIndexPlay.Reset">
            <summary>
            set simulation back to zero
            </summary>
        </member>
        <member name="M:Prac.Core.HistSimIndexPlay.#ctor(Prac.Core.HistSimIndex)">
            <summary>
            create histsimindex player from an index
            </summary>
            <param name="hsi"></param>
        </member>
        <member name="M:Prac.Core.HistSimIndexPlay.#ctor(System.String,Prac.Core.TickFileFilter)">
            <summary>
            create a player from some tickdata, attempt to create index if not present
            </summary>
            <param name="folder"></param>
            <param name="tff"></param>
        </member>
        <member name="M:Prac.Core.HistSimIndexPlay.#ctor(System.String,System.Int32)">
            <summary>
            build index for an entire folder
            </summary>
            <param name="folder"></param>
        </member>
        <member name="P:Prac.Core.HistSimIndexPlay.WaitRead">
            <summary>
             wait between reads
            </summary>
        </member>
        <member name="P:Prac.Core.HistSimIndexPlay.WaitWrite">
            <summary>
             wait between writes
            </summary>
        </member>
        <member name="P:Prac.Core.HistSimIndexPlay.Folder">
            <summary>
            folder where ticks are located
            </summary>
        </member>
        <member name="T:Prac.Core.TikReader">
            <summary>
            read tick files
            </summary>
        </member>
        <member name="F:Prac.Core.TikReader.ApproxTicks">
            <summary>
            estimate of ticks contained in file
            </summary>
        </member>
        <member name="M:Prac.Core.TikReader.ToSecurity">
            <summary>
            security represented by parsing realsymbol
            </summary>
            <returns></returns>
        </member>
        <member name="F:Prac.Core.TikReader.Count">
            <summary>
            count of ticks presently read
            </summary>
        </member>
        <member name="M:Prac.Core.TikReader.NextTick">
            <summary>
            returns true if more data to process, false otherwise
            </summary>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.TikReader.RealSymbol">
            <summary>
            real symbol for data represented in file
            </summary>
        </member>
        <member name="P:Prac.Core.TikReader.Symbol">
            <summary>
            security-parsed symbol
            </summary>
        </member>
        <member name="P:Prac.Core.TikReader.isValid">
            <summary>
            file is readable, has version and real symbol
            </summary>
        </member>
        <member name="P:Prac.Core.HistSimMemory.inMemory">
            <summary>
            whether simulation is run in memory.
            if disabled runs as a histsimindexplay
            </summary>
        </member>
        <member name="M:Prac.Core.BrokerFeed.#ctor">
            <summary>
            create a new brokerfeed with default parameters
            </summary>
        </member>
        <member name="M:Prac.Core.BrokerFeed.#ctor(Prac.API.Providers,Prac.API.Providers,System.Boolean)">
            <summary>
            create broker feed
            </summary>
            <param name="feed"></param>
            <param name="broker"></param>
            <param name="useany"></param>
            <param name="threadsafe"></param>
        </member>
        <member name="M:Prac.Core.BrokerFeed.#ctor(Prac.API.Providers,Prac.API.Providers,Prac.API.Providers,System.Boolean,System.String,System.String[],System.Int32)">
            <summary>
            if you provide ip addresses, BF will use IP as the transport.
            otherwise it uses windows ipc/messaging
            </summary>
            <param name="feed"></param>
            <param name="broker"></param>
            <param name="useany"></param>
            <param name="threadsafe"></param>
            <param name="program"></param>
            <param name="servers"></param>
            <param name="port"></param>
        </member>
        <member name="M:Prac.Core.BrokerFeed.Subscribe(Prac.API.Basket)">
            <summary>
            subscribe to symbols from feed provider
            </summary>
            <param name="b"></param>
        </member>
        <member name="M:Prac.Core.BrokerFeed.Unsubscribe">
            <summary>
            unsubscribe symbols from feed provider
            </summary>
        </member>
        <member name="M:Prac.Core.BrokerFeed.Register">
            <summary>
            register with providers
            </summary>
        </member>
        <member name="M:Prac.Core.BrokerFeed.PCSend(Prac.API.MessageTypes,System.String)">
            <summary>
            send a message to providers
            </summary>
            <param name="type"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BrokerFeed.PCSend(Prac.API.MessageTypes,System.Int64,System.Int64,System.Int64,System.String,System.String@)">
            <summary>
            send a message to providers
            </summary>
            <param name="type"></param>
            <param name="source"></param>
            <param name="dest"></param>
            <param name="msgid"></param>
            <param name="message"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BrokerFeed.Start">
            <summary>
            start broker feed
            </summary>
        </member>
        <member name="M:Prac.Core.BrokerFeed.Reset">
            <summary>
            reset brokerfeed, look for any new servers and attempt to connect to current preferred providers
            </summary>
        </member>
        <member name="M:Prac.Core.BrokerFeed.RequestPositions(System.String)">
            <summary>
            request positions for a given account
            </summary>
            <param name="acct"></param>
        </member>
        <member name="M:Prac.Core.BrokerFeed.RequestAccounts">
            <summary>
            request accounts available on connection
            </summary>
        </member>
        <member name="P:Prac.Core.BrokerFeed.isPreferredFeed">
            <summary>
            returns whether preferred feed is being used
            </summary>
        </member>
        <member name="P:Prac.Core.BrokerFeed.isPreferredBroker">
            <summary>
            returns whether preferred broker is being used
            </summary>
        </member>
        <member name="P:Prac.Core.BrokerFeed.FeedClient">
            <summary>
            returns current client being used for feed
            </summary>
        </member>
        <member name="P:Prac.Core.BrokerFeed.BrokerClient">
            <summary>
            returns client of broker provider
            </summary>
        </member>
        <member name="P:Prac.Core.BrokerFeed.Feed">
            <summary>
            returns current feed provider
            </summary>
        </member>
        <member name="P:Prac.Core.BrokerFeed.Broker">
            <summary>
            returns current broker provider
            </summary>
        </member>
        <member name="P:Prac.Core.BrokerFeed.RequirePreferred">
            <summary>
            whether feed/broker connections will be attempted if preferred options are not available
            </summary>
        </member>
        <member name="P:Prac.Core.BrokerFeed.ServerVersion">
            <summary>
            not used.   call BrokerClient.ServerVersion or FeedClient.ServerVersion
            </summary>
        </member>
        <member name="P:Prac.Core.BrokerFeed.BrokerName">
            <summary>
            not used.   See Broker or Feed properties.
            </summary>
        </member>
        <member name="P:Prac.Core.BrokerFeed.RequestPositionsOnAccounts">
            <summary>
            request positions automatically when accounts are received
            </summary>
        </member>
        <member name="P:Prac.Core.BrokerFeed.RequestAccountsOnStartup">
            <summary>
            request accounts when connection is reset or started
            </summary>
        </member>
        <member name="P:Prac.Core.BrokerFeed.isFeedConnected">
            <summary>
            whether feed is connected
            </summary>
        </member>
        <member name="P:Prac.Core.BrokerFeed.isBrokerConnected">
            <summary>
            whether broker is connected
            </summary>
        </member>
        <member name="P:Prac.Core.BrokerFeed.VerboseDebugging">
            <summary>
            enable/disable extended debugging
            </summary>
        </member>
        <member name="T:Prac.Core.TradeImpl">
            <summary>
            A trade or execution of a stock order.  Also called a fill.
            </summary>
        </member>
        <member name="M:Prac.Core.TradeImpl.#ctor">
            <summary>
            true if this is a real Trade, otherwise it's still an order.
            </summary>
        </member>
        <member name="M:Prac.Core.TradeImpl.Serialize(Prac.API.Trade)">
            <summary>
            Serialize trade as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TradeImpl.Deserialize(System.String)">
            <summary>
            Deserialize string to Trade
            </summary>
            <returns></returns>
        </member>
        <member name="T:Prac.Core.MOCOrder">
            <summary>
            market on close order
            </summary>
        </member>
        <member name="T:Prac.Core.OrderImpl">
            <summary>
            Specify an order to buy or sell a quantity of a security.
            </summary>
        </member>
        <member name="M:Prac.Core.OrderImpl.Fill(Prac.API.Tick)">
            <summary>
            Fills this order with a tick
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OrderImpl.Fill(Prac.API.Tick,System.Boolean,System.Boolean)">
            <summary>
            fill against bid and ask rather than trade
            </summary>
            <param name="k"></param>
            <param name="smart"></param>
            <param name="fillOPG"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OrderImpl.Fill(Prac.API.Tick,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            fill assuming high liquidity - fill stops and limits at their stop price
            rather than at bid, ask, or trade. primarily for use when only daily data is available.
            </summary>
            <param name="k"></param>
            <param name="bidask"></param>
            <param name="fillOPG"></param>
            <param name="fillAtStop"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OrderImpl.FillBidAsk(Prac.API.Tick,System.Boolean)">
            <summary>
            fill against bid and ask rather than trade
            </summary>
            <param name="k"></param>
            <param name="OPG"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OrderImpl.FillBidAsk(Prac.API.Tick)">
            <summary>
            fill against bid and ask rather than trade
            </summary>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OrderImpl.Fill(Prac.API.Order)">
            <summary>
            Try to fill incoming order against this order.  If orders match.
            </summary>
            <param name="o"></param>
            <returns>order can be cast to valid Trade and function returns true.  Otherwise, false</returns>
        </member>
        <member name="M:Prac.Core.OrderImpl.Serialize(Prac.API.Order)">
            <summary>
            Serialize order as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OrderImpl.Deserialize(System.String)">
            <summary>
            Deserialize string to Order
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTrule.rulepasses(System.Int32,System.String,Prac.API.GenericTrackerI[])">
            <summary>
            test a rule made up of trackers
            </summary>
            <param name="idx"></param>
            <param name="rulename"></param>
            <param name="booltrackers"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTrule.rulepasses(System.Int32,System.String,Prac.API.DebugDelegate,Prac.API.GenericTrackerI[])">
            <summary>
            test a rule made up of trackers
            </summary>
            <param name="idx"></param>
            <param name="rulename"></param>
            <param name="debug"></param>
            <param name="booltrackers"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTrule.rulepasses(System.Int32,System.String,Prac.API.DebugDelegate,System.Boolean,Prac.API.GenericTrackerI[])">
            <summary>
            test a rule made up of trackers
            </summary>
            <param name="idx"></param>
            <param name="rulename"></param>
            <param name="debug"></param>
            <param name="debugfails"></param>
            <param name="booltrackers"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTrule.rulepasses(System.Int32,System.String,System.Boolean,Prac.API.DebugDelegate,System.Boolean,Prac.API.GenericTrackerI[])">
            <summary>
            test a rule made up of trackers... optionally display the passes or failures.
            </summary>
            <param name="idx"></param>
            <param name="rulename"></param>
            <param name="debug"></param>
            <param name="debugfails"></param>
            <param name="booltrackers"></param>
            <returns></returns>
        </member>
        <member name="T:Prac.Core.TikConst">
            <summary>
            constants for working with Tik files
            </summary>
        </member>
        <member name="T:Prac.Core.PositionTracker">
            <summary>
            easily trade positions for a collection of securities.
            automatically builds positions from existing positions and new trades.
            </summary>
        </member>
        <member name="M:Prac.Core.PositionTracker.#ctor">
            <summary>
            track positions
            </summary>
        </member>
        <member name="M:Prac.Core.PositionTracker.#ctor(System.Int32)">
            <summary>
            track positions
            </summary>
            <param name="estposcount"></param>
        </member>
        <member name="M:Prac.Core.PositionTracker.Clear">
            <summary>
            clear all positions.  use with caution.
            also resets default account.
            </summary>
        </member>
        <member name="M:Prac.Core.PositionTracker.SetDefault(System.String,System.String)">
            <summary>
            set default account for symbol
            </summary>
            <param name="sym"></param>
            <param name="account"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.SetDefaultAccount(System.Int32,System.String)">
            <summary>
            set default account for symbol
            </summary>
            <param name="sym"></param>
            <param name="account"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.getpos(System.String)">
            <summary>
            get a position
            </summary>
            <param name="symbol"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.getpos(System.String,System.String)">
            <summary>
            get a position
            </summary>
            <param name="symbol"></param>
            <param name="account"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.getpos_empty(System.Int32)">
            <summary>
            get an empty position
            </summary>
            <param name="symidx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.getpos_empty(System.Int32,System.String)">
            <summary>
            get an empty position
            </summary>
            <param name="symidx"></param>
            <param name="account"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.getpos_empty(System.String)">
            <summary>
            get an empty position
            </summary>
            <param name="symbol"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.getpos_empty(System.String,System.String)">
            <summary>
            get an empty position
            </summary>
            <param name="symbol"></param>
            <param name="account"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.getpos(System.Int32)">
            <summary>
            get a position
            </summary>
            <param name="symidx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.getpos(System.Int32,System.String)">
            <summary>
            get a position
            </summary>
            <param name="symidx"></param>
            <param name="account"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.getpos(System.Int32,System.Int32)">
            <summary>
            get a position
            </summary>
            <param name="symidx"></param>
            <param name="actidx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.getaccount_index(System.String,System.String)">
            <summary>
            get position index for an specific account
            </summary>
            <param name="sym"></param>
            <param name="account"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.getaccount_index(System.Int32)">
            <summary>
            get account index for default account
            </summary>
            <param name="symidx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.getaccount_index(System.String)">
            <summary>
            get account index for default account
            </summary>
            <param name="symbol"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.getaccount_index(System.Int32,System.String)">
            <summary>
            get position index for an specific account
            </summary>
            <param name="symidx"></param>
            <param name="account"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.NewPosition(Prac.API.Position)">
            <summary>
            Create a new position, or overwrite existing position
            </summary>
            <param name="newpos"></param>
        </member>
        <member name="M:Prac.Core.PositionTracker.ispostracked(System.Int32,Prac.API.Trade)">
            <summary>
            test whether position is already tracked
            </summary>
            <param name="symidx"></param>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.ispostracked(Prac.API.Trade)">
            <summary>
            test whether position is already tracked
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.ispostracked(System.Int32,Prac.API.Position)">
            <summary>
            test whether position is already tracked
            </summary>
            <param name="symidx"></param>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.ispostracked(Prac.API.Position)">
            <summary>
            test whether position is already tracked
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.ispostracked(System.String,System.String)">
            <summary>
            test whether position is already tracked
            </summary>
            <param name="symbol"></param>
            <param name="account"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.ispostracked(System.Int32,System.String)">
            <summary>
            test whether position is already tracked
            </summary>
            <param name="symidx"></param>
            <param name="account"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.ispostracked(System.Int32,System.Int32)">
            <summary>
            test whether position is already tracked
            </summary>
            <param name="symidx"></param>
            <param name="actidx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.Adjust(Prac.API.Trade)">
            <summary>
            Adjust an existing position, or create a new one... given a trade and symbol+account index
            </summary>
            <param name="fill"></param>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.Adjust(System.Int32,Prac.API.Trade)">
            <summary>
            adjust an indexed symbol
            </summary>
            <param name="idx"></param>
            <param name="fill"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.dopositiontrack_overwrite(System.Int32,System.Int32,Prac.API.Position)">
            <summary>
            overwrite an existing position
            </summary>
            <param name="idx"></param>
            <param name="actidx"></param>
            <param name="pos"></param>
        </member>
        <member name="M:Prac.Core.PositionTracker.dopositiontrack_new(System.Int32,Prac.API.Trade)">
            <summary>
            track a new position from first fill
            </summary>
            <param name="idx"></param>
            <param name="t"></param>
        </member>
        <member name="M:Prac.Core.PositionTracker.dopositiontrack_new(System.Int32,Prac.API.Position)">
            <summary>
            track a new position
            </summary>
            <param name="idx"></param>
            <param name="pos"></param>
        </member>
        <member name="M:Prac.Core.PositionTracker.Adjust(Prac.API.Position)">
            <summary>
            overwrite existing position, or start new position
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.ToArray">
            <summary>
            get all positions in all tracked accounts
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionTracker.ToArray(System.String)">
            <summary>
            get all positions in a tracked account
            </summary>
            <param name="account"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.PositionTracker.DefaultAccount">
            <summary>
            Default account used when querying positions
            (if never set by user, defaults to first account provided via adjust)
            </summary>
        </member>
        <member name="P:Prac.Core.PositionTracker.Item(System.String)">
            <summary>
            get position given positions symbol (assumes default account)
            </summary>
            <param name="symbol"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.PositionTracker.Item(System.Int32)">
            <summary>
            get default position for a symbol
            </summary>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.PositionTracker.Item(System.Int32,System.Int32)">
            <summary>
            get position for a given symbol/account
            </summary>
            <param name="idx"></param>
            <param name="actidx"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.PositionTracker.Item(System.Int32,System.String)">
            <summary>
            get position for a given symbol/account
            </summary>
            <param name="idx"></param>
            <param name="account"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.PositionTracker.Item(System.String,System.String)">
            <summary>
            get a position in tracker given symbol and account
            </summary>
            <param name="symbol"></param>
            <param name="account"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.PositionTracker.TotalClosedPL">
            <summary>
            gets sum of all closed pl for all positions
            </summary>
        </member>
        <member name="E:Prac.Core.PositionTracker.NewSymbol">
            <summary>
            called when a new position is added to tracker.
            </summary>
        </member>
        <member name="P:Prac.Core.PositionTracker.id">
            <summary>
            numerical id of this tracker
            </summary>
        </member>
        <member name="P:Prac.Core.PositionTracker.smallid">
            <summary>
            integer version of tracker id
            </summary>
        </member>
        <member name="T:Prac.Core.qdl_stockprice">
            <summary>
            this data is described here: https://www.quandl.com/help/api-for-stock-data#API-for-Stock-Prices
            </summary>
        </member>
        <member name="T:Prac.Core.BarListImpl">
            <summary>
            Holds a succession of bars.  Will acceptt ticks and automatically create new bars as needed.
            </summary>
        </member>
        <member name="M:Prac.Core.BarListImpl.Int2BarInterval(System.Int32[])">
            <summary>
            converts integer array of intervals to BarIntervals... supplying custom interval for any unrecognized interval types.
            </summary>
            <param name="intervals"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.BarInterval2Int(Prac.API.BarInterval[])">
            <summary>
            converts array of BarIntervals to integer intervals.
            </summary>
            <param name="ints"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.#ctor(System.String)">
            <summary>
            creates barlist with defined symbol and requests all intervals
            </summary>
            <param name="symbol"></param>
        </member>
        <member name="M:Prac.Core.BarListImpl.#ctor(Prac.API.BarInterval,System.String)">
            <summary>
            creates a barlist with requested interval and defined symbol
            </summary>
            <param name="interval"></param>
            <param name="symbol"></param>
        </member>
        <member name="M:Prac.Core.BarListImpl.#ctor(System.String,System.Int32)">
            <summary>
            creates a barlist with requested custom interval and defined symbol
            </summary>
            <param name="symbol"></param>
            <param name="interval"></param>
        </member>
        <member name="M:Prac.Core.BarListImpl.#ctor(System.String,System.Int32,Prac.API.BarInterval)">
            <summary>
            creates a barlist with custom interval and a custom type (tick/vol)
            </summary>
            <param name="symbol"></param>
            <param name="interval"></param>
            <param name="type"></param>
        </member>
        <member name="M:Prac.Core.BarListImpl.#ctor(Prac.API.BarInterval)">
            <summary>
            creates a barlist with requested interval.  symbol will be defined by first tick received
            </summary>
            <param name="interval"></param>
        </member>
        <member name="M:Prac.Core.BarListImpl.#ctor">
            <summary>
            creates barlist with no symbol defined and requests 5min bars
            </summary>
        </member>
        <member name="M:Prac.Core.BarListImpl.#ctor(System.String,Prac.API.BarInterval[])">
            <summary>
            creates barlist with specified symbol and requested intervals
            </summary>
            <param name="symbol"></param>
            <param name="intervals"></param>
        </member>
        <member name="M:Prac.Core.BarListImpl.#ctor(Prac.API.BarList)">
            <summary>
            make copy of a barlist.  remember you must re-setup GotNewBar events after using this.
            </summary>
            <param name="original"></param>
        </member>
        <member name="M:Prac.Core.BarListImpl.backfillbars(System.String,System.Decimal[],System.Int32,System.Int32,Prac.Core.BarListTracker@,System.Int32,Prac.API.DebugDelegate)">
            <summary>
            fill bars with arbitrary price data for a symbol
            </summary>
            <param name="sym"></param>
            <param name="prices"></param>
            <param name="startdate"></param>
            <param name="blt"></param>
            <param name="interval"></param>
            <param name="debugs"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.InsertBar(Prac.API.BarList,Prac.API.Bar,System.Int32)">
            <summary>
            insert a bar at particular place in the list.
            REMEMBER YOU MUST REHANDLE GOTNEWBAR EVENT AFTER CALLING THIS.
            </summary>
            <param name="bl"></param>
            <param name="b"></param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.InsertBarList(Prac.API.BarList,Prac.API.BarList)">
            <summary>
            insert one barlist into another barlist
            REMEMBER: You must re-handle the GotNewBar event after calling this method.
            You should also ensure that inserted barlist has same intervals/types as original barlist.
            </summary>
            <param name="bl"></param>
            <param name="insert"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.#ctor(System.String,System.Int32[],Prac.API.BarInterval[])">
            <summary>
            creates a barlist with array of custom intervals
            </summary>
            <param name="symbol"></param>
            <param name="custintervals"></param>
        </member>
        <member name="F:Prac.Core.BarListImpl._defaultcustint">
            <summary>
            gets or sets the default interval in seconds
            </summary>
        </member>
        <member name="M:Prac.Core.BarListImpl.IntervalCount(Prac.API.BarInterval,System.Int32)">
            <summary>
            gets count for given bar interval
            </summary>
            <param name="interval"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.Has(System.Int32,Prac.API.BarInterval,System.Int32)">
            <summary>
            returns true if barslist has at least minimum # of bars for specified interval
            </summary>
            <param name="minBars"></param>
            <param name="interval"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.Has(System.Int32)">
            <summary>
            returns true if barlist has at least minimum # of bars for default interval
            </summary>
            <param name="minBars"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.Reset">
            <summary>
            erases all bar data
            </summary>
        </member>
        <member name="M:Prac.Core.BarListImpl.FromCSV(System.String,System.String,System.Int32)">
            <summary>
            Create a barlist from a succession of bar records provided as comma-delimited OHLC+volume data.
            </summary>
            <param name="symbol">The symbol.</param>
            <param name="filedata">The file containing the CSV records.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.GetNearestIntraBar(Prac.API.BarList,System.Int32,Prac.API.BarInterval)">
            <summary>
            find the bar # that matches a given time
            </summary>
            <param name="bl"></param>
            <param name="time"></param>
            <param name="bint"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.DayFromURL(System.String,System.String,System.Boolean,System.Boolean,Prac.API.DebugDelegate)">
            <summary>
            Populate the day-interval barlist of this instance from a URL, where the results are returned as a CSV file.  URL should accept requests in the form of http://url/get.py?sym=IBM
            </summary>
            <param name="url">The URL.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.DayFromAny(System.String,Prac.API.DebugDelegate)">
            <summary>
            attempts to get year worth of daily data from google, if fails tries yahoo.
            </summary>
            <param name="symbol"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.DayFromGoogle(System.String,System.Int32,System.Int32)">
            <summary>
            gets specific date range of bars from google
            </summary>
            <param name="symbol"></param>
            <param name="startdate"></param>
            <param name="enddate"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.DayFromGoogle(System.String)">
            <summary>
            Populate the day-interval barlist using google finance as the source.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.FromEPF(System.String)">
            <summary>
            Build a barlist using an EPF file as the source
            </summary>
            <param name="filename">The filename.</param>
            <returns>barlist</returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.FromTIK(System.String)">
            <summary>
            get a barlist from tick data
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.FromTIK(System.String,System.Boolean,System.Boolean)">
            <summary>
            get a barlist from tick data and optionally use bid/ask data to construct bars
            </summary>
            <param name="filename"></param>
            <param name="uselast"></param>
            <param name="usebid"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.FromTIK(System.String,System.Boolean,System.Boolean,System.Int32[],Prac.API.BarInterval[])">
            <summary>
            create barlist from a tik file using given intervals/types
            </summary>
            <param name="filename"></param>
            <param name="uselast"></param>
            <param name="usebid"></param>
            <param name="intervals"></param>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.GetBarIndexPreceeding(Prac.API.BarList,System.Int32)">
            <summary>
            gets index of bar that preceeds given date
            </summary>
            <param name="chart"></param>
            <param name="date"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.GetBarIndexPreceeding(Prac.API.BarList,System.Int32,System.Int32)">
            <summary>
            gets preceeding bar by time (assumes same day)
            </summary>
            <param name="chart"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.GetBarPreceeding(Prac.API.BarList,System.Int32)">
            <summary>
            gets bar that preceeds a given date (invalid if no preceeding bar)
            </summary>
            <param name="chart"></param>
            <param name="date"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.DayFromYahoo(System.String)">
             <summary>
             Populate the day-interval barlist using google finance as the source.
             </summary>
             <returns></returns>
            
        </member>
        <member name="M:Prac.Core.BarListImpl.DayFromEuronext(System.String)">
             <summary>
             Populate the day-interval barlist using Euronext.com as the source.
             </summary>
             <param name="isin">The ISIN (mnemonics not accepted)</param>
             <returns></returns>
            
        </member>
        <member name="M:Prac.Core.BarListImpl.GetUniqueIntervals(Prac.API.BarInterval[])">
            <summary>
            given some number of intervals, return a list of same intervals with duplicates removed
            </summary>
            <param name="ints"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarListImpl.GetUniqueIntervals(System.Int32[])">
            <summary>
            given some number of intervals, return a list of same intervals with duplicates removed
            </summary>
            <param name="ints"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.BarListImpl.ALLINTERVALS">
            <summary>
            gets array of all possible non custom bar intevals
            </summary>
        </member>
        <member name="P:Prac.Core.BarListImpl.DefaultIntervalIndex">
            <summary>
            index to current default interval pair (type/size)
            </summary>
        </member>
        <member name="P:Prac.Core.BarListImpl.Intervals">
            <summary>
            gets intervals available/requested by this barlist when it was created
            </summary>
        </member>
        <member name="P:Prac.Core.BarListImpl.CustomIntervals">
            <summary>
            gets all available/requested intervals as a custom array of integers
            </summary>
        </member>
        <member name="P:Prac.Core.BarListImpl.NewBar">
            <summary>
            set true for new bar.  don't use this, use GotNewBar event as it's faster.
            </summary>
        </member>
        <member name="P:Prac.Core.BarListImpl.symbol">
            <summary>
            symbol for bar
            </summary>
        </member>
        <member name="P:Prac.Core.BarListImpl.isValid">
            <summary>
            returns true if bar has symbol and has requested intervals
            </summary>
        </member>
        <member name="P:Prac.Core.BarListImpl.First">
            <summary>
            gets first bar in any interval
            </summary>
        </member>
        <member name="P:Prac.Core.BarListImpl.DefaultInterval">
            <summary>
            gets or sets the default interval in bar intervals
            </summary>
        </member>
        <member name="P:Prac.Core.BarListImpl.Item(System.Int32)">
            <summary>
            gets specific bar in specified interval
            </summary>
            <param name="barnumber"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.BarListImpl.Item(System.Int32,Prac.API.BarInterval,System.Int32)">
            <summary>
            gets a specific bar in specified interval
            </summary>
            <param name="barnumber"></param>
            <param name="interval"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.BarListImpl.Item(System.Int32,System.Int32)">
            <summary>
            gets a specific bar in specified seconds interval
            </summary>
            <param name="barnumber"></param>
            <param name="interval"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.BarListImpl.Last">
            <summary>
            gets the last bar in default interval
            </summary>
        </member>
        <member name="P:Prac.Core.BarListImpl.Count">
            <summary>
            gets the # of bars in default interval
            </summary>
        </member>
        <member name="P:Prac.Core.BarListImpl.RecentBar">
            <summary>
            gets most recent bar from default interval
            </summary>
        </member>
        <member name="E:Prac.Core.BarListImpl.GotNewBar">
            <summary>
            this event is thrown when a new bar arrives
            </summary>
        </member>
        <member name="T:Prac.Core.BarImpl">
            <summary>
            A single bar of price data, which represents OHLC and volume for an interval of time.
            </summary>
        </member>
        <member name="M:Prac.Core.BarImpl.newTick(Prac.API.Tick)">
            <summary>
            Accepts the specified tick.
            </summary>
            <param name="t">The tick you want to add to the bar.</param>
            <returns>true if the tick is accepted, false if it belongs to another bar.</returns>
        </member>
        <member name="M:Prac.Core.BarImpl.FromCSV(System.String,System.String,System.Int32)">
            <summary>
            Create bar object from a CSV file providing OHLC+Volume data.
            </summary>
            <param name="record">The record in comma-delimited format.</param>
            <returns>The equivalent Bar</returns>
        </member>
        <member name="M:Prac.Core.BarImpl.ToTick(Prac.API.Bar)">
            <summary>
            convert a bar into an array of ticks
            </summary>
            <param name="bar"></param>
            <returns></returns>
        </member>
        <member name="T:Prac.Core.PCServer_WM">
            <summary>
            tradelink servers allow tradelink clients to talk to any supported broker with common interface.
            this version of server supports communication with clients via windows messaging.
            </summary>
        </member>
        <member name="M:Prac.Core.PCServer_WM.newTick(Prac.API.Tick)">
            <summary>
            Notifies subscribed clients of a new tick.
            </summary>
            <param name="tick">The tick to include in the notification.</param>
        </member>
        <member name="M:Prac.Core.PCServer_WM.newFill(Prac.API.Trade)">
            <summary>
            Notifies subscribed clients of a new execution.
            </summary>
            <param name="trade">The trade to include in the notification.</param>
        </member>
        <member name="P:Prac.Core.PCServer_WM.VerboseDebugging">
            <summary>
            toggle higher level of debugging
            </summary>
        </member>
        <member name="T:Prac.Core.PCTransportType">
            <summary>
            transport type
            </summary>
        </member>
        <member name="T:Prac.Core.IPUtil">
            <summary>
            ip util class
            </summary>
        </member>
        <member name="M:Prac.Core.IPUtil.isValidAddress(System.String)">
            <summary>
            true if an ip address in string format is valid
            </summary>
            <param name="ipaddr"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.IPUtil.hasValidAddress(System.String[])">
            <summary>
            returns true if an array has at least one valid address
            </summary>
            <param name="servers"></param>
            <returns></returns>
        </member>
        <member name="T:Prac.Core.ParamPrompt">
            <summary>
            Param Prompt quickly creates a GUI to edit properties of your Response
            </summary>
        </member>
        <member name="M:Prac.Core.ParamPrompt.#ctor(Prac.API.Response)">
            <summary>
            You create a param prompt to display a gui for your Response
            </summary>
            <param name="DisplayParamsOfObject">The Response for which you want the user to specify or alter the properties for.</param>
        </member>
        <member name="M:Prac.Core.ParamPrompt.Popup(Prac.API.Response)">
            <summary>
            popup the parameters for selected response
            </summary>
        </member>
        <member name="M:Prac.Core.ParamPrompt.Popup(Prac.API.Response,System.Boolean,System.Boolean)">
            <summary>
            pop up the parameters, allows you to pausing the application to do so (also can skip prompt)
            </summary>
            <param name="pauseapp"></param>
        </member>
        <member name="T:Prac.Core.TickTracker">
            <summary>
            keep track of bid/ask and last data for symbols
            </summary>
        </member>
        <member name="M:Prac.Core.TickTracker.ValueDecimal(System.Int32)">
            <summary>
            gets decimal value of last trade price for given index
            </summary>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.ValueDecimal(System.String)">
            <summary>
            gets decimal value of last trade price given label
            </summary>
            <param name="txt"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.#ctor">
            <summary>
            create ticktracker
            </summary>
        </member>
        <member name="M:Prac.Core.TickTracker.#ctor(System.Int32)">
            <summary>
            create ticktracker with some approximate # of symbols to track
            </summary>
            <param name="estlabels"></param>
        </member>
        <member name="M:Prac.Core.TickTracker.addindex(System.String)">
            <summary>
            track a new symbol
            </summary>
            <param name="symbol"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.getindex(System.String)">
            <summary>
            get index of an existing symbol
            </summary>
            <param name="symbol"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.Bid(System.Int32)">
            <summary>
            get the bid
            </summary>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.Bid(System.String)">
            <summary>
            get the bid
            </summary>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.Ask(System.Int32)">
            <summary>
            get the ask
            </summary>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.Ask(System.String)">
            <summary>
            get the ask
            </summary>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.Last(System.Int32)">
            <summary>
            get the last trade
            </summary>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.Last(System.String)">
            <summary>
            get the last trade
            </summary>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.HasBid(System.Int32)">
            <summary>
            whether we have a bid
            </summary>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.HasBid(System.String)">
            <summary>
            whether we have a bid
            </summary>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.HasAsk(System.String)">
            <summary>
            whether we have a ask
            </summary>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.HasAsk(System.Int32)">
            <summary>
            whether we have a ask
            </summary>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.HasLast(System.Int32)">
            <summary>
            whether we have a last price
            </summary>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.HasLast(System.String)">
            <summary>
            whether we have a last price
            </summary>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.HasAll(System.String)">
            <summary>
            whether we have a bid/ask and last
            </summary>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.HasAll(System.Int32)">
            <summary>
            whether we have a bid/ask and last
            </summary>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.HasQuote(System.String)">
            <summary>
            whether we have a bid/ask
            </summary>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.HasQuote(System.Int32)">
            <summary>
            whether we have a bid/ask
            </summary>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.Tick(System.Int32)">
            <summary>
            get a tick in tick format
            </summary>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.Tick(System.String)">
            <summary>
            get a tick in tick format
            </summary>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickTracker.newTick(Prac.API.Tick,System.Int32)">
            <summary>
            update the tracker with a new tick
            </summary>
            <param name="k"></param>
            <param name="idx"></param>
        </member>
        <member name="M:Prac.Core.TickTracker.newTick(Prac.API.Tick)">
            <summary>
            update the tracker with a new tick
            </summary>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="E:Prac.Core.TickTracker.NewTxt">
            <summary>
            called when new text label is added
            </summary>
        </member>
        <member name="P:Prac.Core.TickTracker.id">
            <summary>
            numerical id of this tracker
            </summary>
        </member>
        <member name="P:Prac.Core.TickTracker.smallid">
            <summary>
            integer version of tracker id
            </summary>
        </member>
        <member name="P:Prac.Core.TickTracker.Item(System.Int32)">
            <summary>
            get a tick in tick format
            </summary>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.TickTracker.Item(System.String)">
            <summary>
            get a tick in tick format
            </summary>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="T:Prac.Core.HistSimIndex">
            <summary>
            builds an index for faster playback of historical simulation
            </summary>
        </member>
        <member name="M:Prac.Core.HistSimIndex.Serialize(Prac.Core.HistSimIndex)">
            <summary>
            serialize index
            </summary>
            <param name="hsi"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.HistSimIndex.Deserialize(System.String)">
            <summary>
            deserialize an index
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.HistSimIndex.BuildIndex(System.String,Prac.Core.TickFileFilter,Prac.Core.HistSimIndex@,System.Boolean)">
            <summary>
            get index from a set of tick files given a filter
            </summary>
            <param name="folder"></param>
            <param name="tff"></param>
            <param name="hsi"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.HistSimIndex.BuildIndex(System.String,Prac.Core.TickFileFilter,Prac.Core.HistSimIndex@)">
            <summary>
            get index from a set of tick files given a filter and starts indexing
            </summary>
            <param name="folder"></param>
            <param name="tff"></param>
            <param name="hsi"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.HistSimIndex.BuildIndex(System.String,System.String[0:,0:],Prac.Core.TickFileFilter,Prac.Core.HistSimIndex@,System.Boolean)">
            <summary>
            get index from set of tick files given a filter
            </summary>
            <param name="tickfiles"></param>
            <param name="tff"></param>
            <param name="hsi"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.HistSimIndex.BuildIndex(System.String,System.String[0:,0:],Prac.Core.TickFileFilter,Prac.Core.HistSimIndex@)">
            <summary>
            gets index from set of tick files and starts indexing
            </summary>
            <param name="tickfiles"></param>
            <param name="tff"></param>
            <param name="hsi"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.HistSimIndex.BuildIndex(System.String,System.String[0:,0:],Prac.Core.HistSimIndex@)">
            <summary>
            gets index for given set of tick files
            </summary>
            <param name="tickfiles"></param>
            <param name="hsi"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.HistSimIndex.BuildIndex(System.String,System.String[0:,0:],Prac.Core.HistSimIndex@,System.Boolean)">
            <summary>
            gets index for set of tick files
            </summary>
            <param name="tickfiles"></param>
            <param name="hsi"></param>
            <param name="start">whether to build the index or just the TOC</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.HistSimIndex.#ctor(System.String,System.String[0:,0:],System.Int32)">
            <summary>
            prepares to index a set of tickfiles
            </summary>
            <param name="tickfiles"></param>
        </member>
        <member name="M:Prac.Core.HistSimIndex.#ctor">
            <summary>
            create empty index
            </summary>
        </member>
        <member name="M:Prac.Core.HistSimIndex.Start">
            <summary>
            build the index
            </summary>
        </member>
        <member name="M:Prac.Core.HistSimIndex.Reset">
            <summary>
            resets everything
            </summary>
        </member>
        <member name="M:Prac.Core.HistSimIndex.Stop">
            <summary>
            stops indexing if running
            </summary>
        </member>
        <member name="F:Prac.Core.HistSimIndex.SLEEP">
            <summary>
            polling delay in ms, how often index data load is checked for completion
            </summary>
        </member>
        <member name="M:Prac.Core.HistSimIndex.Equals(Prac.Core.HistSimIndex)">
            <summary>
            whether two indicies are equivalent (index same files)
            </summary>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.HistSimIndex.FromFile(System.String)">
            <summary>
            gets a serialized index from a file
            </summary>
            <param name="filepath"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.HistSimIndex.ToFile(Prac.Core.HistSimIndex,System.String)">
            <summary>
            serialize idnex as a file
            </summary>
            <param name="hsi"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.HistSimIndex.HaveIndex(System.String,Prac.Core.TickFileFilter,System.String@)">
            <summary>
            checks whether we already have an index built for a given pre-filtered data set
            </summary>
            <param name="folder"></param>
            <param name="tff"></param>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.HistSimIndex.HaveIndex(System.String,System.String[0:,0:],System.String@,Prac.API.DebugDelegate)">
            <summary>
            checks whether we already have an index for a given (post-filtered) data set
            </summary>
            <param name="folder"></param>
            <param name="tickfiles"></param>
            <param name="file"></param>
            <param name="debug"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.HistSimIndex.HaveIndex(System.String,System.String[0:,0:],System.Int32,System.String@)">
            <summary>
            checks whether we already have an index built for a given data set.
            if index is empty, deletes index.
            </summary>
            <param name="folder"></param>
            <param name="tff"></param>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.HistSimIndex.Folder">
            <summary>
            folder where tick files are located
            </summary>
        </member>
        <member name="P:Prac.Core.HistSimIndex.IndexFolder">
            <summary>
            folder where index files are located
            </summary>
        </member>
        <member name="P:Prac.Core.HistSimIndex.isRunning">
            <summary>
            whether index is presently running/building
            </summary>
        </member>
        <member name="P:Prac.Core.HistSimIndex.isComplete">
            <summary>
            whether all files in index were read successfully
            </summary>
        </member>
        <member name="P:Prac.Core.HistSimIndex.isBinaryIndex">
            <summary>
            whether binary index is used to complement text index
            </summary>
        </member>
        <member name="P:Prac.Core.HistSimIndex.BinaryIndex">
            <summary>
            name of binary index file if used
            </summary>
        </member>
        <member name="P:Prac.Core.HistSimIndex.Playtimes">
            <summary>
            playtimes corresponding with playindicies
            </summary>
        </member>
        <member name="P:Prac.Core.HistSimIndex.Playindex">
            <summary>
            playorder of tickfiles in index
            </summary>
        </member>
        <member name="P:Prac.Core.HistSimIndex.TOC">
            <summary>
            tickfiles making up index and their sizes
            </summary>
        </member>
        <member name="P:Prac.Core.HistSimIndex.TOCTicks">
            <summary>
            used by serializer, do not use.
            </summary>
        </member>
        <member name="P:Prac.Core.HistSimIndex.TOCSizes">
            <summary>
            used by serializer, do not use
            </summary>
        </member>
        <member name="P:Prac.Core.HistSimIndex.isReady">
            <summary>
            returns true if it has some index data ready for playback
            </summary>
        </member>
        <member name="P:Prac.Core.HistSimIndex.TicksPresent">
            <summary>
            ticks present in index
            </summary>
        </member>
        <member name="P:Prac.Core.HistSimIndex.Interval">
            <summary>
            bar interval in seconds
            </summary>
        </member>
        <member name="T:Prac.Core.RandomTicks">
            <summary>
            create an array of ticks that is a random walk from an initial set of ticks.
            walk varies between +MaxMoveCents and -MaxMoveCents.
            at present no quotes are generated, only trades.
            </summary>
        </member>
        <member name="M:Prac.Core.RandomTicks.#ctor(System.Int32)">
            <summary>
            create random ticks for desired number of symbols
            </summary>
            <param name="symcount"></param>
        </member>
        <member name="M:Prac.Core.RandomTicks.RandomPrices(System.Int32)">
            <summary>
            gets desired number of random [initial] prices.
            </summary>
            <param name="pricecount"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.RandomTicks.RandomPrices(System.Int32,System.Int32)">
            <summary>
            provides a group of random prices
            </summary>
            <param name="pricecout"></param>
            <param name="seed"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.RandomTicks.#ctor(System.String[],System.Int32)">
            <summary>
            creates ticks from list of symbols and a seed value
            </summary>
            <param name="symbols"></param>
            <param name="seed"></param>
        </member>
        <member name="M:Prac.Core.RandomTicks.#ctor(System.String[])">
            <summary>
            creates random ticks from a list of symbols, with randomized initial prices
            </summary>
            <param name="symbols"></param>
        </member>
        <member name="M:Prac.Core.RandomTicks.#ctor(System.String[],System.Decimal[],System.Int32)">
            <summary>
            creates random ticks for a list of symbols and starting prices.
            prices should be in same order for symbol they represent.
            </summary>
            <param name="symbols">list of symbols</param>
            <param name="startingprices">opening trade for each symbol</param>
        </member>
        <member name="M:Prac.Core.RandomTicks.Generate(System.Int32)">
            <summary>
            generate Ticks per symbol using a random walk from initial prices
            </summary>
            <param name="Ticks"></param>
        </member>
        <member name="M:Prac.Core.RandomTicks.GenerateSymbol(System.String,System.Int32)">
            <summary>
            generate random ticks for single symbol
            </summary>
            <param name="sym"></param>
            <param name="Ticks"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.RandomTicks.Symbols">
            <summary>
            obtain list of symbols
            </summary>
        </member>
        <member name="P:Prac.Core.RandomTicks.Ticks">
            <summary>
            obtain randomized ticks.  each 1st dimension array corresponds to Symbol in same-position of this.Symbols[]
            Ticks are listed sequentionally in the 2nd dimension.
            </summary>
        </member>
        <member name="P:Prac.Core.RandomTicks.MaxMoveCents">
            <summary>
            random walk varies between +MaxMoveCents and -MaxMoveCents
            </summary>
        </member>
        <member name="P:Prac.Core.RandomTicks.VolPerTrade">
            <summary>
            volume to use on each tick
            </summary>
        </member>
        <member name="M:Prac.Core.OrderHelper.PositionProfit(Prac.API.Position,System.Decimal)">
            <summary>
            Defaults to 100% of position at target.
            </summary>
            <param name="p">your position</param>
            <param name="offset">your target</param>
            <returns>profit taking limit order</returns>
        </member>
        <member name="M:Prac.Core.OrderHelper.PositionProfit(Prac.API.Position,System.Decimal,System.Decimal)">
            <summary>
            Generates profit taking order for a given position, at a specified per-share profit target.  
            </summary>
            <param name="p">your position</param>
            <param name="offset">target price, per share/contract</param>
            <param name="percent">percent of the position to close with this order</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OrderHelper.PositionProfit(Prac.API.Position,System.Decimal,System.Decimal,System.Boolean,System.Int32)">
            <summary>
            Generates profit taking order for a given position, at a specified per-share profit target.  
            </summary>
            <param name="p">your position</param>
            <param name="offset">target price, per share/contract</param>
            <param name="percent">percent of the position to close with this order</param>
            <param name="normalizesize">whether to normalize order to be an even-lot trade</param>
            <param name="MINSIZE">size of an even lot</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OrderHelper.PositionStop(Prac.API.Position,System.Decimal)">
            <summary>
            Generate a stop order for a position, at a specified per-share/contract price.  Defaults to 100% of position.
            </summary>
            <param name="p">your position</param>
            <param name="offset">how far away stop is</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OrderHelper.PositionStop(Prac.API.Position,System.Decimal,System.Decimal)">
            <summary>
            Generate a stop order for a position, at a specified per-share/contract price
            </summary>
            <param name="p">your position</param>
            <param name="offset">how far away stop is</param>
            <param name="percent">what percent of position to close</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OrderHelper.PositionStop(Prac.API.Position,System.Decimal,System.Decimal,System.Boolean,System.Int32)">
            <summary>
            Generate a stop order for a position, at a specified per-share/contract price
            </summary>
            <param name="p">your position</param>
            <param name="offset">how far away stop is</param>
            <param name="percent">what percent of position to close</param>
            <param name="normalizesize">whether to normalize size to even-lots</param>
            <param name="MINSIZE">size of an even lot</param>
            <returns></returns>
        </member>
        <member name="T:Prac.Core.OversellTracker">
            <summary>
            prevent or adjust oversell/overcovers
            </summary>
        </member>
        <member name="M:Prac.Core.OversellTracker.sendcancel(System.Int64)">
            <summary>
            ensure that if splits are enabled, cancels for the original order also are copied to the split
            </summary>
            <param name="id"></param>
        </member>
        <member name="M:Prac.Core.OversellTracker.sendorder(Prac.API.Order)">
            <summary>
            track and correct oversells (either by splitting into two orders, or dropping oversell)
            </summary>
            <param name="o"></param>
        </member>
        <member name="P:Prac.Core.OversellTracker.Split">
            <summary>
            split oversells into two orders (otherwise, oversold portion is dropped)
            </summary>
        </member>
        <member name="F:Prac.Core.Quandl.APIK">
            <summary>
            set the quandl api key
            </summary>
        </member>
        <member name="M:Prac.Core.Quandl.BuildQdlCode(System.String,System.String[])">
            <summary>
            gets quandl datacode given source and column/symbol
            </summary>
            <param name="source"></param>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Quandl.BuildQdlCode(Prac.Core.qdl_ds,Prac.Core.qdl_freq,System.String[])">
            <summary>
            gets quandl datacode given source and symbol
            </summary>
            <param name="source"></param>
            <param name="symbol"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Quandl.GetQdlDataCode(Prac.Core.qdl_ds)">
            <summary>
            get string-ified version of qdl data set code
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Quandl.Get(Prac.Core.qdl_ds,System.String)">
            <summary>
            get a quandl data set for particular symbol/column
            </summary>
            <param name="ds"></param>
            <param name="symbol"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Quandl.Get(System.String)">
            <summary>
            gets a quandl data object directly from url
            </summary>
            <param name="qurl"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Quandl.Get(System.String,Prac.API.DebugDelegate)">
            <summary>
            gets a quandl data object directly from url
            </summary>
            <param name="qurl"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Quandl.Get(System.String,System.Boolean,Prac.API.DebugDelegate)">
            <summary>
            gets a quandl data object directly from url
            </summary>
            <param name="qurl"></param>
            <param name="TryCache"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Quandl.Get(Prac.Core.qdl_ds,System.String,System.String)">
            <summary>
            get a quandl data set for particular symbol/column
            </summary>
            <param name="ds"></param>
            <param name="symbol"></param>
            <param name="additionaldataset"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Quandl.Get(Prac.Core.qdl_ds,System.String,System.String,Prac.API.DebugDelegate)">
            <summary>
            get a quandl data set for particular symbol/column
            </summary>
            <param name="ds"></param>
            <param name="symbol"></param>
            <param name="additionaldataset"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Quandl.Get(Prac.Core.qdl_ds,System.String,Prac.API.DebugDelegate)">
            <summary>
            get a quandl data set for particular symbol/column
            </summary>
            <param name="ds"></param>
            <param name="symbol"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Quandl.Get(Prac.Core.qdl_ds,System.String,System.Boolean,Prac.API.DebugDelegate)">
            <summary>
            get a quandl data set for particular symbol/column
            </summary>
            <param name="ds"></param>
            <param name="symbol"></param>
            <param name="trycache"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Quandl.Get(Prac.Core.qdl_ds,System.String,System.String,System.Boolean,Prac.API.DebugDelegate)">
            <summary>
            get a quandl data set for particular symbol/column (no frequency)
            </summary>
            <param name="ds"></param>
            <param name="symbol"></param>
            <param name="additionaldataset"></param>
            <param name="trycache"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Quandl.Get(Prac.Core.qdl_ds,System.String,System.String,Prac.Core.qdl_freq,System.Boolean,Prac.API.DebugDelegate)">
            <summary>
            get a quandl data set for particular symbol/column/frequency
            </summary>
            <param name="ds"></param>
            <param name="symbol"></param>
            <param name="trycache"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="F:Prac.Core.qdl_ds.None">
            <summary>
            no data source
            </summary>
        </member>
        <member name="F:Prac.Core.qdl_ds.StockPriceNA">
            <summary>
            north american stock prices
            </summary>
        </member>
        <member name="F:Prac.Core.qdl_ds.SECRaw">
            <summary>
            sec database raw format
            </summary>
        </member>
        <member name="F:Prac.Core.qdl_ds.SecHarm">
            <summary>
            sec database in easily comparable format
            </summary>
        </member>
        <member name="F:Prac.Core.qdl_ds.ZacksEarnings">
            <summary>
            zacks equities earnings 
            </summary>
        </member>
        <member name="F:Prac.Core.qdl_ds.ZacksSurprises">
            <summary>
            zacks equities earnings estimates and misses
            </summary>
        </member>
        <member name="F:Prac.Core.qdl_ds.NYUProfessorDamodaran">
            <summary>
            fundamentals and ratios
            </summary>
        </member>
        <member name="F:Prac.Core.qdl_freq.None">
            <summary>
            none or N/A
            </summary>
        </member>
        <member name="T:Prac.Core.Account">
            <summary>
            A token used to identify one brokerage account from another.
            </summary>
        </member>
        <member name="P:Prac.Core.Account.isValid">
            <summary>
            Gets a value indicating whether this instance is valid.
            </summary>
            <value><c>true</c> if this instance is valid; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Prac.Core.Account.ID">
            <summary>
            Gets the ID of this account.
            </summary>
            <value>The ID.</value>
        </member>
        <member name="P:Prac.Core.Account.Desc">
            <summary>
            Gets or sets the description for this account.
            </summary>
            <value>The desc.</value>
        </member>
        <member name="T:Prac.Core.StopOrder">
            <summary>
            A stop-loss order.
            </summary>
        </member>
        <member name="T:Prac.Core.BuyStop">
            <summary>
            Create a buystop order.
            </summary>
        </member>
        <member name="T:Prac.Core.SellStop">
            <summary>
            Create a sellstop order.
            </summary>
        </member>
        <member name="T:Prac.Core.TrailStop">
            <summary>
            Create a trailing stop order
            </summary>
        </member>
        <member name="T:Prac.Core.TikWriter">
            <summary>
            write tick files
            </summary>
        </member>
        <member name="F:Prac.Core.TikWriter.Count">
            <summary>
            ticks written
            </summary>
        </member>
        <member name="M:Prac.Core.TikWriter.#ctor">
            <summary>
            creates a tikwriter with no header, header is created from first tik
            </summary>
        </member>
        <member name="M:Prac.Core.TikWriter.#ctor(System.String)">
            <summary>
            create a tikwriter for a specific symbol on todays date.
            auto-creates header
            </summary>
            <param name="realsymbol"></param>
        </member>
        <member name="M:Prac.Core.TikWriter.#ctor(System.String,System.Int32)">
            <summary>
            create a tikwriter for specific symbol on specific date
            auto-creates header
            </summary>
            <param name="realsymbol"></param>
            <param name="date"></param>
        </member>
        <member name="M:Prac.Core.TikWriter.#ctor(System.String,System.String,System.Int32)">
            <summary>
            create tikwriter with specific location, symbol and date.
            auto-creates header
            </summary>
            <param name="path"></param>
            <param name="realsymbol"></param>
            <param name="date"></param>
        </member>
        <member name="M:Prac.Core.TikWriter.Close">
            <summary>
            close a tickfile
            </summary>
        </member>
        <member name="M:Prac.Core.TikWriter.SafeFilename(System.String,System.String,System.Int32)">
            <summary>
            gets symbol safe to use as filename
            </summary>
            <param name="realsymbol"></param>
            <param name="path"></param>
            <param name="date"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TikWriter.SafeSymbol(System.String)">
            <summary>
            gets symbol that is safe to use as filename
            </summary>
            <param name="realsymbol"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TikWriter.Header(Prac.Core.TikWriter,System.String)">
            <summary>
            write header for tick file
            </summary>
            <param name="bw"></param>
            <param name="realsymbol"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TikWriter.newTick(Prac.API.Tick)">
            <summary>
            write a tick to file
            </summary>
            <param name="k"></param>
        </member>
        <member name="M:Prac.Core.TikWriter.newTick(Prac.Core.TickImpl)">
            <summary>
            write a tick to file
            </summary>
            <param name="k"></param>
        </member>
        <member name="P:Prac.Core.TikWriter.RealSymbol">
            <summary>
            real symbol represented by tick file
            </summary>
        </member>
        <member name="P:Prac.Core.TikWriter.Filepath">
            <summary>
            path of this file
            </summary>
        </member>
        <member name="P:Prac.Core.TikWriter.Date">
            <summary>
            date represented by data
            </summary>
        </member>
        <member name="M:Prac.Core.MessageTracker.#ctor">
            <summary>
            create a message tracker
            </summary>
        </member>
        <member name="M:Prac.Core.MessageTracker.#ctor(Prac.API.PracClient)">
            <summary>
            create a message tracker that communicates with a PCclient
            </summary>
            <param name="tl"></param>
        </member>
        <member name="E:Prac.Core.MessageTracker.GotOpenPrice">
            <summary>
            thrown if open price is received
            </summary>
        </member>
        <member name="E:Prac.Core.MessageTracker.GotClosePrice">
            <summary>
            triggered if most recent close is received
            </summary>
        </member>
        <member name="E:Prac.Core.MessageTracker.GotHighPrice">
            <summary>
            triggered if day high is received (any exchange, all day)
            </summary>
        </member>
        <member name="E:Prac.Core.MessageTracker.GotLowPrice">
            <summary>
            triggered if day low is received (any exchange, all day)
            </summary>
        </member>
        <member name="E:Prac.Core.MessageTracker.GotNyseHighPrice">
            <summary>
            triggered if day high is received (nyse only, nyse hours)
            </summary>
        </member>
        <member name="E:Prac.Core.MessageTracker.GotNyseLowPrice">
            <summary>
            triggered if day lowis received (nyse only, nyse hours)
            </summary>
        </member>
        <member name="E:Prac.Core.MessageTracker.GotIntraHighPrice">
            <summary>
            triggered if day high is received (any exchange, nyse hours)
            </summary>
        </member>
        <member name="E:Prac.Core.MessageTracker.GotIntraLowPrice">
            <summary>
            triggered if day lowis received (any exchange, nyse hours)
            </summary>
        </member>
        <member name="E:Prac.Core.MessageTracker.GotFeatures">
            <summary>
            triggered if list of feature is received
            </summary>
        </member>
        <member name="E:Prac.Core.MessageTracker.SendDebug">
            <summary>
            triggered if debug is sent
            </summary>
        </member>
        <member name="E:Prac.Core.MessageTracker.SendMessageResponse">
            <summary>
            triggered if send messageresponse occurs
            </summary>
        </member>
        <member name="E:Prac.Core.MessageTracker.GotProvider">
            <summary>
            triggered if provider is received
            </summary>
        </member>
        <member name="E:Prac.Core.MessageTracker.GotNewBar">
            <summary>
            called if new bar passes through tracker
            </summary>
        </member>
        <member name="P:Prac.Core.MessageTracker.BLT">
            <summary>
            bar list tracker to be updated when bars arrive
            </summary>
        </member>
        <member name="T:Prac.Core.LatencyTracker">
            <summary>
            used to track latency between:
            orders->order acks
            orders->fills
            cancels->cancelack
            </summary>
        </member>
        <member name="M:Prac.Core.LatencyTracker.GotFill(Prac.API.Trade)">
            <summary>
            pass fills through here
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:Prac.Core.LatencyTracker.GotOrder(Prac.API.Order)">
            <summary>
            pass orders through here
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:Prac.Core.LatencyTracker.GotCancel(System.Int32)">
            <summary>
            pass cancels through here
            </summary>
            <param name="id"></param>
        </member>
        <member name="M:Prac.Core.LatencyTracker.GotCancel(System.Int64)">
            <summary>
            pass cancels through here
            </summary>
            <param name="id"></param>
        </member>
        <member name="M:Prac.Core.QuandlHelper.Qdl2GT(Prac.Core.QuandlData.RootObject,Prac.API.DebugDelegate)">
            <summary>
            converts a quandl object into a gt (w/default date,val columns)
            </summary>
            <param name="ro"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.Qdl2GT(Prac.Core.QuandlData.RootObject,System.String,Prac.API.DebugDelegate)">
            <summary>
            converts a quandl object into a gt (w/default date column)
            </summary>
            <param name="ro"></param>
            <param name="valcol"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.Qdl2GT(Prac.Core.QuandlData.RootObject,System.String,System.String,Prac.API.DebugDelegate)">
            <summary>
            convert quandl object to gt
            </summary>
            <param name="ro"></param>
            <param name="datecol"></param>
            <param name="valcol"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.Qdl2GT(Prac.Core.QuandlData.RootObject,System.String,System.String,System.Int32,System.Int32,Prac.API.DebugDelegate)">
            <summary>
            takes all or part of quandl object and converts it into GT
            </summary>
            <param name="ro"></param>
            <param name="datecol"></param>
            <param name="valcol"></param>
            <param name="startrow"></param>
            <param name="endrow"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.dc2str(QuandlCS.Types.Datacode)">
            <summary>
            gets pretty quandl code
            </summary>
            <param name="dc"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.DataCode2String(QuandlCS.Types.Datacode)">
            <summary>
            gets pretty quandl code
            </summary>
            <param name="dc"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.isQdlUnderMaintence">
            <summary>
            tests whether quandl is under maintence
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.isQdlUnderMaintence(Prac.API.DebugDelegate)">
            <summary>
            tests whether quandl is under maintence
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.isQdlUnderMaintence(System.String)">
            <summary>
            tests whether quandl data indicates service is under maintence or down
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.isQdlServiceOk">
            <summary>
            tests whether quandl service is up
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.isQdlServiceOk(Prac.API.DebugDelegate)">
            <summary>
            tests whether quandl service is up
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.isQdlSetOk(Prac.Core.QuandlData.RootObject[])">
            <summary>
            tests whether a quandl result set is ok (not null and has data present)
            </summary>
            <param name="ros"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.isQdlSetOk(Prac.API.DebugDelegate,Prac.Core.QuandlData.RootObject[])">
            <summary>
            tests whether a quandl result set is ok (not null and has data present)
            </summary>
            <param name="ro"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlColidx(Prac.Core.QuandlData.RootObject,System.String)">
            <summary>
            gets a column index from name (case insensitive)
            </summary>
            <param name="ro"></param>
            <param name="colname"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlColidx(Prac.Core.QuandlData.RootObject,System.String,System.Boolean)">
            <summary>
            gets a column index from name (optional case sensitive)
            </summary>
            <param name="ro"></param>
            <param name="colname"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlDataIndex(Prac.Core.QuandlData.RootObject,System.DateTime,Prac.API.DebugDelegate)">
            <summary>
            gets data index of a specific date in default column
            </summary>
            <param name="ro"></param>
            <param name="dt"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlDataIndex(Prac.Core.QuandlData.RootObject,System.DateTime,System.Int32,Prac.API.DebugDelegate)">
            <summary>
            gets date for a given date (and date column index)
            </summary>
            <param name="ro"></param>
            <param name="dt"></param>
            <param name="colidx"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlDataIndex_After(Prac.Core.QuandlData.RootObject,System.DateTime,Prac.API.DebugDelegate)">
            <summary>
            gets first index after a certain date
            </summary>
            <param name="ro"></param>
            <param name="dt"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlDataIndex_After(Prac.Core.QuandlData.RootObject,System.DateTime,System.String,Prac.API.DebugDelegate)">
            <summary>
            gets first index after a certain date
            </summary>
            <param name="ro"></param>
            <param name="dt"></param>
            <param name="datecol"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlDataIndex_After(Prac.Core.QuandlData.RootObject,System.DateTime,System.Int32,Prac.API.DebugDelegate)">
            <summary>
            gets first index after a certain date
            </summary>
            <param name="ro"></param>
            <param name="dt"></param>
            <param name="colidx"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlDataIndex_Before(Prac.Core.QuandlData.RootObject,System.DateTime,Prac.API.DebugDelegate)">
            <summary>
            gets first index before a certain date
            </summary>
            <param name="ro"></param>
            <param name="dt"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlDataIndex_Before(Prac.Core.QuandlData.RootObject,System.DateTime,System.String,Prac.API.DebugDelegate)">
            <summary>
            gets first index before a certain date
            </summary>
            <param name="ro"></param>
            <param name="dt"></param>
            <param name="datecol"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlDataIndex_Before(Prac.Core.QuandlData.RootObject,System.DateTime,System.Int32,Prac.API.DebugDelegate)">
            <summary>
            gets index immediately preceeding certain date
            </summary>
            <param name="ro"></param>
            <param name="dt"></param>
            <param name="colidx"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlDate(Prac.Core.QuandlData.RootObject,System.Int32,Prac.API.DebugDelegate)">
            <summary>
            gets quandl date from a given row (using default column date name)
            </summary>
            <param name="ro"></param>
            <param name="dataidx"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlDate(Prac.Core.QuandlData.RootObject,System.String,System.Int32,Prac.API.DebugDelegate)">
            <summary>
            gets a quandl date given row and column information
            </summary>
            <param name="ro"></param>
            <param name="datacolname"></param>
            <param name="dataidx"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlDate(System.Object)">
            <summary>
            convert raw quandl data to date
            </summary>
            <param name="dateval"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlValue(System.Object)">
            <summary>
            convert raw quandl data to value
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlDate(System.Collections.Generic.List{System.Collections.Generic.List{System.Object}},System.Int32,System.Int32,Prac.API.DebugDelegate)">
            <summary>
            gets quandl date from partial data set
            </summary>
            <param name="data"></param>
            <param name="colidx"></param>
            <param name="dataidx"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.isValidQdlColIdx(System.Int32,Prac.Core.QuandlData.RootObject)">
            <summary>
            returns whether a given column index is valid or not
            </summary>
            <param name="colidx"></param>
            <param name="ro"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.isValidQdlColIdx(System.Int32,System.Collections.Generic.List{System.Collections.Generic.List{System.Object}})">
            <summary>
            returns whether a given column index is valid or not
            </summary>
            <param name="colidx"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.isValidQdlRowIdx(System.Int32,Prac.Core.QuandlData.RootObject)">
            <summary>
            returns whether a given row index is valid or not
            </summary>
            <param name="rowidx"></param>
            <param name="ro"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.isValidQdlRowIdx(System.Int32,System.Collections.Generic.List{System.Collections.Generic.List{System.Object}})">
            <summary>
            returns whether a given row index is valid or not
            </summary>
            <param name="rowidx"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlValue(Prac.Core.QuandlData.RootObject,System.DateTime,Prac.API.DebugDelegate)">
            <summary>
            gets quandl value for given date (default date and value column names)
            </summary>
            <param name="ro"></param>
            <param name="dt"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlValue(Prac.Core.QuandlData.RootObject,System.DateTime,System.String,Prac.API.DebugDelegate)">
            <summary>
            gets quandl value for given date (default date column)
            </summary>
            <param name="ro"></param>
            <param name="dt"></param>
            <param name="valcol"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlValue(Prac.Core.QuandlData.RootObject,System.DateTime,System.String,System.String,Prac.API.DebugDelegate)">
            <summary>
            gets quandl value for a given date
            </summary>
            <param name="ro"></param>
            <param name="dataidx"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlValue(Prac.Core.QuandlData.RootObject,System.Int32,Prac.API.DebugDelegate)">
            <summary>
            gets quandl value for a given row (using default column value name)
            </summary>
            <param name="ro"></param>
            <param name="dataidx"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlValue(Prac.Core.QuandlData.RootObject,System.String,System.Int32,Prac.API.DebugDelegate)">
            <summary>
            gets decimal qdl value
            </summary>
            <param name="ro"></param>
            <param name="colname"></param>
            <param name="dataidx"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlValue(System.Collections.Generic.List{System.Collections.Generic.List{System.Object}},System.Int32,System.Int32,Prac.API.DebugDelegate)">
            <summary>
            gets a quandl value from a partial data set
            </summary>
            <param name="data"></param>
            <param name="colidx"></param>
            <param name="dataidx"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlData(Prac.Core.QuandlData.RootObject,System.String,System.Int32,Prac.API.DebugDelegate)">
            <summary>
            get quandl data given row and column information
            </summary>
            <param name="ro"></param>
            <param name="datacolname"></param>
            <param name="dataidx"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetQdlData(Prac.Core.QuandlData.RootObject,System.Int32,System.Int32,Prac.API.DebugDelegate)">
            <summary>
            gets quandl data given row and column information
            </summary>
            <param name="ro"></param>
            <param name="datacolname"></param>
            <param name="dataidx"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetAllRows(Prac.Core.QuandlData.RootObject,System.Int32,System.Int32,Prac.API.DebugDelegate)">
            <summary>
            gets all data between two rows (inclusive)
            </summary>
            <param name="ro"></param>
            <param name="startidx"></param>
            <param name="endidx"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetColumn_After(Prac.Core.QuandlData.RootObject,System.String,System.Int32)">
            <summary>
            gets columns from end of dataset
            </summary>
            <param name="ro"></param>
            <param name="colname"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetColumn_Until(Prac.Core.QuandlData.RootObject,System.String,System.Int32)">
            <summary>
            gets column from start of data until a certain row
            </summary>
            <param name="ro"></param>
            <param name="colname"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetColumn(Prac.Core.QuandlData.RootObject,System.String,System.Int32,System.Int32)">
            <summary>
            gets column between two rows
            </summary>
            <param name="ro"></param>
            <param name="colname"></param>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetColumn(Prac.Core.QuandlData.RootObject,System.String)">
            <summary>
            gets only a column from data set
            </summary>
            <param name="ro"></param>
            <param name="colname"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetColumn(Prac.Core.QuandlData.RootObject,System.Int32)">
            <summary>
            gets only column from data set
            </summary>
            <param name="ro"></param>
            <param name="colidx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetColumn(System.Collections.Generic.List{System.Collections.Generic.List{System.Object}},System.Int32)">
            <summary>
            gets only a column from a data set
            </summary>
            <param name="data"></param>
            <param name="colidx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.PricesToBarlist(Prac.Core.QuandlData.RootObject,System.String)">
            <summary>
            convert quandl daily prices to barlist
            </summary>
            <param name="ro"></param>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetAllDataWithDates(Prac.Core.QuandlData.RootObject,System.String)">
            <summary>
            pull all date with valid dates
            </summary>
            <param name="ro"></param>
            <param name="colname"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetAllDataWithDates(Prac.Core.QuandlData.RootObject,System.String,Prac.API.DebugDelegate)">
            <summary>
            pull all data with valid dates
            </summary>
            <param name="ro"></param>
            <param name="colname"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.QuandlHelper.GetAllDataWithDates(Prac.Core.QuandlData.RootObject,System.Int32,Prac.API.DebugDelegate)">
            <summary>
            pull all data with valid dates
            </summary>
            <param name="ro"></param>
            <param name="colidx"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="T:Prac.Core.SingleSimImpl">
            <summary>
            historical simulation component.
            plays back many tickfiles insequence over time.
            different than multi-sim, multiple symbols in the same day are not guaranteed to be played back in sequence.
            also processes orders and executions against same tickfiles (via embedded Broker component).
            </summary>
        </member>
        <member name="M:Prac.Core.SingleSimImpl.#ctor">
            <summary>
            Create a historical simulator using default tick folder and null filter
            </summary>
        </member>
        <member name="M:Prac.Core.SingleSimImpl.#ctor(System.String)">
            <summary>
            Create historical simulator with your own tick folder
            </summary>
            <param name="TickFolder"></param>
        </member>
        <member name="M:Prac.Core.SingleSimImpl.#ctor(Prac.Core.TickFileFilter)">
            <summary>
            Create a historical simulator
            </summary>
            <param name="tff"></param>
        </member>
        <member name="M:Prac.Core.SingleSimImpl.#ctor(System.String,Prac.Core.TickFileFilter)">
            <summary>
            Create a historical simulator
            </summary>
            <param name="TickFolder">tick folder to use</param>
            <param name="tff">filter to determine what tick files from folder to use</param>
        </member>
        <member name="M:Prac.Core.SingleSimImpl.#ctor(System.String[])">
            <summary>
            Create a historical simulator
            </summary>
            <param name="filenames">list of tick files to use</param>
        </member>
        <member name="M:Prac.Core.SingleSimImpl.Reset">
            <summary>
            Reset the simulation
            </summary>
        </member>
        <member name="M:Prac.Core.SingleSimImpl.Initialize">
            <summary>
            Reinitialize the cache
            </summary>
        </member>
        <member name="M:Prac.Core.SingleSimImpl.PlayTo(System.Int64)">
            <summary>
            Run simulation to specific time
            </summary>
            <param name="time">Simulation will run until this time (use HistSim.ENDSIM for last time)</param>
        </member>
        <member name="M:Prac.Core.SingleSimImpl.Stop">
            <summary>
            stops any running simulation and closes all data files
            </summary>
        </member>
        <member name="P:Prac.Core.SingleSimImpl.TicksPresent">
            <summary>
            Total ticks available for processing, based on provided filter or tick files.
            </summary>
        </member>
        <member name="P:Prac.Core.SingleSimImpl.TicksProcessed">
            <summary>
            Ticks processed in this simulation run.
            </summary>
        </member>
        <member name="P:Prac.Core.SingleSimImpl.FillCount">
            <summary>
            Fills executed during this simulation run.
            </summary>
        </member>
        <member name="P:Prac.Core.SingleSimImpl.NextTickTime">
            <summary>
            Gets next tick in the simulation
            </summary>
        </member>
        <member name="P:Prac.Core.SingleSimImpl.SimBroker">
            <summary>
            Gets broker used in the simulation
            </summary>
        </member>
        <member name="P:Prac.Core.SingleSimImpl.Folder">
            <summary>
            change the tickfolder histsim scans for historical data
            </summary>
        </member>
        <member name="T:Prac.Core.MarketOrderFlat">
            <summary>
            create market order to flat all or part of a position
            </summary>
        </member>
        <member name="M:Prac.Core.MarketOrderFlat.#ctor(Prac.API.Position)">
            <summary>
            flat 100% of a position
            </summary>
            <param name="current"></param>
        </member>
        <member name="M:Prac.Core.MarketOrderFlat.#ctor(Prac.API.Position,System.Decimal,System.Boolean,System.Int32)">
            <summary>
            flat specified % of a position. 
            if the position is an odd-lot, optionally normalize to a standard lot size (if normalizeSize = true)
            if normalizing, specify lot size
            </summary>
            <param name="current"></param>
            <param name="percent"></param>
            <param name="normalizeSize"></param>
            <param name="MinimumLotSize"></param>
        </member>
        <member name="M:Prac.Core.MarketOrderFlat.#ctor(Prac.API.Position,System.Decimal)">
            <summary>
            flat portion of position, normalizing to 100 shares to avoid odd lots.
            </summary>
            <param name="current"></param>
            <param name="percent"></param>
        </member>
        <member name="T:Prac.Core.BarListTracker">
            <summary>
            used to track lists of bars for MANY symbols.
            BarListTracker (blt) will accept ticks and auto-create bars as barlists as needed.
            Access bars via blt["IBM"].RecentBar.Close
            </summary>
        </member>
        <member name="M:Prac.Core.BarListTracker.#ctor">
            <summary>
            create a barlist tracker with all the intervals available
            (specify only intervals you need to get faster performance)
            </summary>
        </member>
        <member name="F:Prac.Core.BarListTracker._defaultcust">
            <summary>
            default custom interval used by this tracker
            </summary>
        </member>
        <member name="M:Prac.Core.BarListTracker.#ctor(System.Int32)">
            <summary>
            creates tracker for single custom interval
            </summary>
            <param name="custominterval"></param>
        </member>
        <member name="M:Prac.Core.BarListTracker.#ctor(System.Int32[],Prac.API.BarInterval[])">
            <summary>
            creates tracker for number of custom intervals.
            (use this if you want to mix standard and custom intervals)
            </summary>
            <param name="customintervals"></param>
        </member>
        <member name="M:Prac.Core.BarListTracker.#ctor(Prac.API.BarInterval[])">
            <summary>
            creates tracker for specified number of standard intervals
            </summary>
            <param name="intervals"></param>
        </member>
        <member name="M:Prac.Core.BarListTracker.Reset">
            <summary>
            clears all data from tracker
            </summary>
        </member>
        <member name="M:Prac.Core.BarListTracker.newTick(Prac.API.Tick)">
            <summary>
            give any ticks (trades) to this symbol and tracker will create barlists automatically 
            </summary>
            <param name="k"></param>
        </member>
        <member name="M:Prac.Core.BarListTracker.newPoint(System.String,System.Decimal,System.Int32,System.Int32,System.Int32)">
            <summary>
            add any data point to bar
            </summary>
            <param name="symbol"></param>
            <param name="p"></param>
            <param name="time"></param>
            <param name="date"></param>
            <param name="size"></param>
        </member>
        <member name="M:Prac.Core.BarListTracker.newBid(Prac.API.Tick)">
            <summary>
            build bar with bid data rather than trades
            </summary>
            <param name="k"></param>
        </member>
        <member name="M:Prac.Core.BarListTracker.newAsk(Prac.API.Tick)">
            <summary>
            build bar with ask data rather than trades
            </summary>
            <param name="k"></param>
        </member>
        <member name="P:Prac.Core.BarListTracker.Intervals">
            <summary>
            intervals requested when tracker was created
            </summary>
        </member>
        <member name="P:Prac.Core.BarListTracker.CustomIntervals">
            <summary>
            custom bar intervals used by this tracker
            </summary>
        </member>
        <member name="P:Prac.Core.BarListTracker.Item(System.String)">
            <summary>
            gets barlist for a given symbol.   will return an invalid barlist if no ticks have been received for symbol
            </summary>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="T:Prac.Core.TickFileFilter">
            <summary>
            Filters tick files (EPF/IDX) based on symbol name and trading date.
            </summary>
        </member>
        <member name="M:Prac.Core.TickFileFilter.SymFilter(System.String)">
            <summary>
            Adds a symbol filter
            </summary>
            <param name="stock">The stock.</param>
        </member>
        <member name="M:Prac.Core.TickFileFilter.SymFilter(System.String[])">
            <summary>
            Adds an array of symbol filters
            </summary>
            <param name="stocks">The stocks.</param>
        </member>
        <member name="M:Prac.Core.TickFileFilter.DateFilter(Prac.Core.TickFileFilter.PCDateFilter[])">
            <summary>
            Adds an array of PCDateFilters
            </summary>
            <param name="filters">The filters.</param>
        </member>
        <member name="M:Prac.Core.TickFileFilter.DateFilter(Prac.Core.TickFileFilter.PCDateFilter)">
            <summary>
            Adds a single DateFilter
            </summary>
            <param name="datefilter">The datefilter.</param>
        </member>
        <member name="M:Prac.Core.TickFileFilter.DateFilter(System.Int32,Prac.Core.DateMatchType)">
            <summary>
            Adds a single DateFilter
            </summary>
            <param name="date">The date.</param>
            <param name="type">The type.</param>
        </member>
        <member name="M:Prac.Core.TickFileFilter.Allow(System.String)">
            <summary>
            Allows the specified filepath, if instructed by the filter.
            </summary>
            <param name="filepath">The filepath.</param>
            <returns>true if allowed, false otherwise</returns>
        </member>
        <member name="M:Prac.Core.TickFileFilter.Deny(System.String)">
            <summary>
            Denies the specified filepath, if instructed by the filter.
            </summary>
            <param name="filepath">The filepath.</param>
            <returns>true if denied, false otherwise</returns>
        </member>
        <member name="M:Prac.Core.TickFileFilter.Allows(System.String[])">
            <summary>
            Allows the specified filepaths.  Plural version of Allow.
            </summary>
            <param name="filepaths">The filepaths.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickFileFilter.PCYearMask(System.Int32)">
            <summary>
            get a filter that excludes everything but year from PC date
            </summary>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickFileFilter.PCMonthMask(System.Int32)">
            <summary>
            get a filter that excludes everything but the month from PC date
            </summary>
            <param name="month"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickFileFilter.Serialize(Prac.Core.TickFileFilter)">
            <summary>
            serialize a tick file filter
            </summary>
            <param name="tff"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickFileFilter.Deserialize(System.String)">
            <summary>
            take a serialized tickfilefilter and convert back to an object
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickFileFilter.FromFile(System.String)">
            <summary>
            save tickfilefilter to a file
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickFileFilter.ToFile(Prac.Core.TickFileFilter,System.String)">
            <summary>
            restore a filter from a file
            </summary>
            <param name="tff"></param>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.TickFileFilter.DefaultDeny">
            <summary>
            Gets or sets a value indicating whether [default deny] is used when Allow and Deny are called.
            </summary>
            <value><c>true</c> if [default deny]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Prac.Core.TickFileFilter.AllowInvalid">
            <summary>
            Gets or sets a value indicating whether the class will [allow invalid] tickfiles, which have undefined extensions.
            </summary>
            <value><c>true</c> if [allow invalid]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Prac.Core.TickFileFilter.isDateMatchUnion">
            <summary>
            if true, any file that matches ANY date will be allowed.  If false, all dates must match before a tick file is allowed.  default is true.
            </summary>
        </member>
        <member name="P:Prac.Core.TickFileFilter.isSymbolDateMatchUnion">
            <summary>
            if true, any file matching SymbolMatch OR DateMatch will be allowed.   Otherwise, it must be allowed by the Symbol filters AND the Date filters.  default is true.
            </summary>
        </member>
        <member name="T:Prac.Core.TickFileFilter.PCDateFilter">
            <summary>
            match a specific portion of a date (eg month only, year only, etc)
            </summary>
        </member>
        <member name="T:Prac.Core.TickArchiver">
            <summary>
            archive ticks as they arrive.   Once archived, ticks can be replayed, viewed or analyzed.
            </summary>
        </member>
        <member name="T:Prac.Core.TickImpl">
            <summary>
            A tick is both the smallest unit of time and the most simple unit of data in the markets
            It is an abstract container for last trade, last trade size, best bid, best offer, bid and offer sizes.
            </summary>
        </member>
        <member name="M:Prac.Core.TickImpl.Copy(Prac.Core.TickImpl,Prac.Core.TickImpl)">
            <summary>
            this constructor creates a new tick by combining two ticks
            this is to handle tick updates that only provide bid/ask changes.
            </summary>
            <param name="a">old tick</param>
            <param name="b">new tick or update</param>
        </member>
        <member name="P:Prac.Core.TickImpl.bs">
            <summary>
            normal bid size (size/100 for equities, /1 for others)
            </summary>
        </member>
        <member name="P:Prac.Core.TickImpl.os">
            <summary>
            normal ask size (size/100 for equities, /1 for others)
            </summary>
        </member>
        <member name="P:Prac.Core.TickImpl.BidSize">
            <summary>
            tick.bs*100 (only for equities)
            </summary>
        </member>
        <member name="P:Prac.Core.TickImpl.AskSize">
            <summary>
            tick.os*100 (only for equities)
            </summary>
        </member>
        <member name="T:Prac.Core.StopLimitOrder">
            <summary>
            Create stop limit orders.
            </summary>
        </member>
        <member name="T:Prac.Core.BuyStopLimit">
            <summary>
            Create buy stop limit orders.
            </summary>
        </member>
        <member name="T:Prac.Core.SellStopLimit">
            <summary>
            Create sell-stop limit orders.
            </summary>
        </member>
        <member name="F:Prac.Core.BarRequest.Client">
            <summary>
            client making request
            </summary>
        </member>
        <member name="M:Prac.Core.BarRequest.BuildBarRequest(System.String,Prac.API.BarInterval)">
            <summary>
            request historical data for one day back
            </summary>
            <param name="symbol"></param>
            <param name="interval"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarRequest.BuildBarRequest(System.String,Prac.API.BarInterval,System.Int32)">
            <summary>
            bar request for symbol and interval from previous date through present time
            </summary>
            <param name="symbol"></param>
            <param name="interval"></param>
            <param name="startdate"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarRequest.BuildBarRequestBarsBack(System.String,System.Int32,System.Int32)">
            <summary>
            build bar request for certain # of bars back from present
            </summary>
            <param name="sym"></param>
            <param name="barsback"></param>
            <param name="interval"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarRequest.Serialize(Prac.Core.BarRequest)">
            <summary>
            builds bar request
            </summary>
            <param name="br"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarRequest.Deserialize(System.String)">
            <summary>
            parses message into a structured bar request
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="T:Prac.Core.TrailTracker">
            <summary>
            simulate a trailing stop for a number of positions
            </summary>
        </member>
        <member name="F:Prac.Core.TrailTracker.MaxFireCount">
            <summary>
            default max fires per round turn
            </summary>
        </member>
        <member name="M:Prac.Core.TrailTracker.#ctor">
            <summary>
            creates trail tracker (with it's own position tracker)
            </summary>
        </member>
        <member name="M:Prac.Core.TrailTracker.#ctor(Prac.Core.PositionTracker,Prac.Core.IdTracker)">
            <summary>
            creates a trail tracker from an existing position tracker component
            </summary>
            <param name="pt"></param>
        </member>
        <member name="M:Prac.Core.TrailTracker.newTick(Prac.API.Tick)">
            <summary>
            must pass ticks as received to this function, in order to have trailing stops executed at proper time.
            </summary>
            <param name="k"></param>
        </member>
        <member name="M:Prac.Core.TrailTracker.newPoint(System.String,System.Decimal)">
            <summary>
            pass arbitrary price to use for trail reference price
            </summary>
            <param name="symbol"></param>
            <param name="p"></param>
        </member>
        <member name="M:Prac.Core.TrailTracker.Adjust(Prac.API.Position)">
            <summary>
            this must be called once per position tracker, for each position update.
            if you are using your own position tracker with this trailing stop(eg from offset tracker, or somewhere else)
            you only need to adjust it once, so if you adjust it directly you don't need to call again here.
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:Prac.Core.TrailTracker.Adjust(Prac.API.Trade)">
            <summary>
            this must be called once per position tracker, for each position update.
            if you are using your own position tracker with this trailing stop(eg from offset tracker, or somewhere else)
            you MUST call TrailTrackers Adjust and NOT call your position tracker's adjust
            </summary>
            <param name="fill"></param>
        </member>
        <member name="P:Prac.Core.TrailTracker.pt">
            <summary>
            position tracker used by this component
            </summary>
        </member>
        <member name="P:Prac.Core.TrailTracker.Item(System.String)">
            <summary>
            gets or sets the trail amount for a given symbol
            </summary>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.TrailTracker.TrailByDefault">
            <summary>
            whether trailing stops are created by default for any symbol seen
            </summary>
        </member>
        <member name="P:Prac.Core.TrailTracker.DefaultTrail">
            <summary>
            when TrailByDefault is enabled, default trail amount is used for symbols that do not have a trail configured
            </summary>
        </member>
        <member name="P:Prac.Core.TrailTracker.isValid">
            <summary>
            set to true if trailing stop are used, false if not
            </summary>
        </member>
        <member name="P:Prac.Core.TrailTracker.UseBidAskExitPrices">
            <summary>
            uses bid/ask rather than last trade to price trailing stop amount
            </summary>
        </member>
        <member name="T:Prac.Core.PCClient_WM">
            <summary>
            clients can connect to any supported broker/server.
            version of the client that supports the protocol via windows messaging transport.
            </summary>
        </member>
        <member name="M:Prac.Core.PCClient_WM.Mode">
            <summary>
            Sets the preferred communication channel of the link, if multiple channels are avaialble.
            Defaults to first provider found.
            </summary>
            <param name="mode">The mode.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PCClient_WM.PCSend(Prac.API.MessageTypes)">
            <summary>
            sends a message to server.  
            synchronous responses are returned immediately as a long
            asynchronous responses come via their message type, or UnknownMessage event otherwise
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PCClient_WM.SendOrderStatus(Prac.API.Order)">
            <summary>
            Sends the order.
            </summary>
            <param name="o">The oorder</param>
            <returns>Zero if succeeded, Broker error code otherwise.</returns>
        </member>
        <member name="M:Prac.Core.PCClient_WM.RequestFeatures">
            <summary>
            request a list of features, result will be returned to gotFeatureResponse and RequestFeaturesList
            </summary>
        </member>
        <member name="M:Prac.Core.PCClient_WM.CancelOrder(System.Int64)">
            <summary>
            Request an order be canceled
            </summary>
            <param name="orderid">the id of the order being canceled</param>
        </member>
        <member name="M:Prac.Core.PCClient_WM.RequestAccounts">
            <summary>
            Send an account request, response is returned via the gotAccounts event.
            </summary>
            <returns>error code, and list of accounts via the gotAccounts event.</returns>
            
        </member>
        <member name="M:Prac.Core.PCClient_WM.RequestImbalances">
            <summary>
            send a request so that imbalances are sent when received (via gotImbalance)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PCClient_WM.RequestPositions(System.String)">
            <summary>
            Sends a request for current positions.  gotPosition event will fire for each position record held by the broker.
            </summary>
            <param name="account">account to obtain position list for (required)</param>
            <returns>number of positions to expect</returns>
        </member>
        <member name="P:Prac.Core.PCClient_WM.VerboseDebugging">
            <summary>
            verbose debugging
            </summary>
        </member>
        <member name="P:Prac.Core.PCClient_WM.MeH">
            <summary>
            Gets or sets my handle of the parent application or form.
            </summary>
            <value>Me H.</value>
        </member>
        <member name="T:Prac.Core.TickWatcher">
            <summary>
            Used to watch a stream of ticks, and send alerts when the stream goes idle for a specified time.
            </summary>
        </member>
        <member name="M:Prac.Core.TickWatcher.newTick(Prac.API.Tick)">
            <summary>
            Watches the specified tick.
            Alerts if wait time exceeded.
            </summary>
            <param name="tick">The tick.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickWatcher.SendAlerts">
            <summary>
            send alerts for idle symbols using current time as comparison point
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TickWatcher.SendAlerts(System.DateTime)">
            <summary>
            Sends the alerts for tickstreams who have gone idle based on the provided datetime.
            </summary>
            <param name="date">The current datetime.</param>
        </member>
        <member name="M:Prac.Core.TickWatcher.SendAlerts(System.Int32)">
            <summary>
            sends alerts for i
            </summary>
            <param name="date"></param>
        </member>
        <member name="M:Prac.Core.TickWatcher.SendAlerts(System.Int32,System.Int32)">
            <summary>
            Sends the alerts for tickstreams who have gone idle based on the provided datetime.
            </summary>
            <param name="date">The datetime.</param>
            <param name="AlertSecondsWithoutTick">The alert seconds without tick.</param>
        </member>
        <member name="M:Prac.Core.TickWatcher.#ctor(System.Int32,Prac.API.GenericTrackerI)">
            <summary>
            creates a tickwatcher and polls specificed millseconds
            if timer has expired, sends alert.
            Background polling occurs in addition to tick-induced time checks.
            </summary>
            <param name="BackgroundPollIntervalms">Value in millseconds to wait between checks.  0 = disable background checks</param>
        </member>
        <member name="P:Prac.Core.TickWatcher.Count">
            <summary>
             returns count of symbols that have ticked at least once
            </summary>
        </member>
        <member name="P:Prac.Core.TickWatcher.Item(System.String)">
            <summary>
            gets last time a tick was received for symbol
            </summary>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.TickWatcher.isMassAlertCleared">
            <summary>
            will be true if mass alerted existed previously and was cleared.
            this value can only be checked once as it will reset to false once read
            </summary>
        </member>
        <member name="E:Prac.Core.TickWatcher.GotMassAlert">
            <summary>
            alert thrown when no ticks have arrived since AlertThreshold.
            Time of last tick is provided.
            </summary>
        </member>
        <member name="E:Prac.Core.TickWatcher.GotAlert">
            <summary>
            alert thrown when AlertThreshold is exceeded for a symbol
            </summary>
        </member>
        <member name="E:Prac.Core.TickWatcher.GotFirstTick">
            <summary>
            alert thrown when first tick arrives for symbol
            </summary>
        </member>
        <member name="P:Prac.Core.TickWatcher.AlertThreshold">
            <summary>
            minimum threshold in seconds when no tick updates have been received for a single symbol, alerts can be thrown.
            </summary>
        </member>
        <member name="P:Prac.Core.TickWatcher.SymbolsNeverTicked">
            <summary>
            gets list of symbols that have never had ticks pass through watcher
            </summary>
        </member>
        <member name="P:Prac.Core.TickWatcher.SymbolsTicked">
            <summary>
            gets stringified symbols which have had ticks pass through the watcher
            </summary>
        </member>
        <member name="P:Prac.Core.TickWatcher.MassAlertThreshold">
            <summary>
            minimum threshold when no ticks have been received for many symbols
            </summary>
        </member>
        <member name="P:Prac.Core.TickWatcher.RecentTime">
            <summary>
            most recent time received
            </summary>
        </member>
        <member name="P:Prac.Core.TickWatcher.TickCount">
            <summary>
            gets count of ticks which have passed through watcher
            </summary>
        </member>
        <member name="P:Prac.Core.TickWatcher.isMassAlerting">
            <summary>
            whether mass alert is firing or not
            </summary>
        </member>
        <member name="P:Prac.Core.TickWatcher.ActiveSymbolTracker">
            <summary>
            gets reference to active symbol tracker
            </summary>
        </member>
        <member name="P:Prac.Core.TickWatcher.CheckLiveAfterTickCount">
            <summary>
            wait to do live test after X ticks have arrived
            </summary>
        </member>
        <member name="P:Prac.Core.TickWatcher.CheckLiveMaxDelaySec">
            <summary>
            if a tick is within this many seconds of current system time on same day, tick stream is considered live and reports can be sent
            </summary>
        </member>
        <member name="T:Prac.Core.ResponseTemplate">
            <summary>
            Template for most typical response.  Inherit from this to create a symbol grey or black strategy.
            eg:
            public class MyStrategy : ResponseTemplate
            {
            }
            </summary>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.GotTick(Prac.API.Tick)">
            <summary>
            Called when new ticks are recieved
            here is where you respond to ticks, eg to populate a barlist
            this.MyBarList.newTick(tick);
            </summary>
            <param name="tick"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.GotOrder(Prac.API.Order)">
            <summary>
            Called when new orders received
            track or respond to orders here, eg:
            this.MyOrders.Add(order);
            </summary>
            <param name="order"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.GotFill(Prac.API.Trade)">
            <summary>
            Called when orders are filled as trades.
            track or respond to trades here, eg:
            positionTracker.Adjust(fill);
            </summary>
            <param name="fill"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.GotOrderCancel(System.Int64)">
            <summary>
            Called if a cancel has been processed
            </summary>
            <param name="cancelid"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.GotMessage(Prac.API.PracMessage@)">
            <summary>
            called when unknown message arrives.   
            </summary>
            <param name="type"></param>
            <param name="id"></param>
            <param name="data"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.Reset">
            <summary>
            Call this to reset your response parameters.
            You might need to reset groups of indicators or internal counters.
            eg : MovingAverage = 0;
            </summary>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.D(System.String)">
            <summary>
            short form of senddebug
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.O(Prac.API.Order)">
            <summary>
            short form of sendorder
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.C(System.Int64)">
            <summary>
            short form of sendcancel
            </summary>
            <param name="id"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.I(System.String)">
            <summary>
            short form of sendindicator
            </summary>
            <param name="indicators"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.I(System.Object[])">
            <summary>
            short form of sendindicator
            </summary>
            <param name="indicators"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.I(System.String[])">
            <summary>
            short form of sendindicator
            </summary>
            <param name="indicators"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.sendorder(Prac.API.Order)">
            <summary>
            sends an order
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.sendcancel(System.Int64)">
            <summary>
            cancels an order (must have the id)
            </summary>
            <param name="id"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.sendindicators(System.Object[])">
            <summary>
            sends indicators as array of objects for later analysis
            </summary>
            <param name="indicators"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.sendindicators(System.String[])">
            <summary>
            send indicators as array of strings for later analysis
            </summary>
            <param name="indicators"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.sendindicators(System.String)">
            <summary>
            sends indicators as a comma seperated string (for later analsis)
            </summary>
            <param name="indicators"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.sendbasket(System.String[])">
            <summary>
            requests ticks for a basket of securities
            </summary>
            <param name="syms"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.sendbasket(Prac.API.Basket)">
            <summary>
            request ticks for a basket of securities
            </summary>
            <param name="syms"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.SB(System.String[])">
            <summary>
            requests ticks for basket of securities
            </summary>
            <param name="syms"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.sendmessage(Prac.API.MessageTypes,System.Int64,System.String,System.String)">
            <summary>
            sends a message
            </summary>
            <param name="type"></param>
            <param name="id"></param>
            <param name="data"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.senddebug(System.String)">
            <summary>
            sends a debug message about what your response is doing at the moment.
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.sendchartlabel">
            <summary>
            clears the chart
            </summary>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.sendchartlabel(System.Decimal,System.Int32,System.String)">
            <summary>
            draws a label with default color (violet)
            </summary>
            <param name="price"></param>
            <param name="time"></param>
            <param name="text"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.sendchartlabel(System.Decimal,System.Int32,System.String,System.Drawing.Color)">
            <summary>
            draws text directly on a point on chart
            </summary>
            <param name="price"></param>
            <param name="time"></param>
            <param name="text"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.sendchartlabel(System.Decimal,System.Int32)">
            <summary>
            draws line with default color (orage)
            </summary>
            <param name="price"></param>
            <param name="time"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.sendchartlabel(System.Decimal,System.Int32,System.Drawing.Color)">
            <summary>
            draws a line between this and previous point drawn
            </summary>
            <param name="price"></param>
            <param name="time"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.CL">
            <summary>
            same as sendchartlabel
            </summary>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.CL(System.Decimal,System.Int32,System.Drawing.Color)">
            <summary>
            same as sendchartlabel
            </summary>
            <param name="price"></param>
            <param name="time"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.CL(System.Decimal,System.Int32,System.String,System.Drawing.Color)">
            <summary>
            same as sendchartlabel
            </summary>
            <param name="price"></param>
            <param name="time"></param>
            <param name="text"></param>
        </member>
        <member name="M:Prac.Core.ResponseTemplate.GotPosition(Prac.API.Position)">
            <summary>
            called when a position update is received (usually only when the response is initially loaded)
            </summary>
            <param name="p"></param>
        </member>
        <member name="P:Prac.Core.ResponseTemplate.ID">
            <summary>
            numeric tag for this response used by programs that load responses
            </summary>
        </member>
        <member name="P:Prac.Core.ResponseTemplate.isValid">
            <summary>
            Whether response can be used or not
            </summary>
        </member>
        <member name="P:Prac.Core.ResponseTemplate.Indicators">
            <summary>
            Names of the indicators used by your response.
            Length must correspond to actual indicator values send with SendIndicators event
            </summary>
        </member>
        <member name="P:Prac.Core.ResponseTemplate.Name">
            <summary>
            Custom name of response set by you
            </summary>
        </member>
        <member name="P:Prac.Core.ResponseTemplate.FullName">
            <summary>
            Full name of this response set by programs (includes namespace)
            </summary>
        </member>
        <member name="T:Prac.Core.BasketImpl">
            <summary>
            Holds collections of securities.
            </summary>
        </member>
        <member name="M:Prac.Core.BasketImpl.Subtract(System.String[],System.String[])">
            <summary>
            gets symbols removed from new list of symbols, given original list
            </summary>
            <param name="old"></param>
            <param name="newb"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BasketImpl.Subtract(Prac.API.Basket,Prac.API.Basket)">
            <summary>
            gets symbols removed from newbasket, given original basket
            </summary>
            <param name="old"></param>
            <param name="newb"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BasketImpl.#ctor(System.String)">
            <summary>
            Create a basket of securities
            </summary>
            <param name="onesymbol">first symbol</param>
        </member>
        <member name="M:Prac.Core.BasketImpl.#ctor(System.String[])">
            <summary>
            Create a basket of securities
            </summary>
            <param name="symbolist">symbols</param>
        </member>
        <member name="M:Prac.Core.BasketImpl.#ctor(Prac.API.Basket)">
            <summary>
            clone a basket
            </summary>
            <param name="copy"></param>
        </member>
        <member name="M:Prac.Core.BasketImpl.#ctor(Prac.Core.SecurityImpl)">
            <summary>
            Create a basket of securities
            </summary>
            <param name="firstsec">security</param>
        </member>
        <member name="M:Prac.Core.BasketImpl.#ctor(Prac.Core.SecurityImpl[])">
            <summary>
            Create a basket of securities
            </summary>
            <param name="securities"></param>
        </member>
        <member name="M:Prac.Core.BasketImpl.Add(System.String)">
            <summary>
            adds a security if not already present
            </summary>
            <param name="sym"></param>
        </member>
        <member name="M:Prac.Core.BasketImpl.Add(Prac.API.Security)">
            <summary>
            adds a security if not already present
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:Prac.Core.BasketImpl.isSecurityPresent(Prac.API.Security)">
            <summary>
            whether security is present
            </summary>
            <param name="sec"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BasketImpl.isSymbolPresent(System.String)">
            <summary>
            whether short symbol is present
            </summary>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BasketImpl.isFullSymbolPresent(System.String)">
            <summary>
            whether full symbol is present
            </summary>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BasketImpl.isAnySymbolPresent(System.String)">
            <summary>
            whether symbol can be found by long or short form
            </summary>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BasketImpl.TryGetSecurityFullSymbol(System.String,Prac.API.Security@)">
            <summary>
            attempt to get security by long symbol
            </summary>
            <param name="sym"></param>
            <param name="sec"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BasketImpl.TryGetSecurityShortSymbol(System.String,Prac.API.Security@)">
            <summary>
            attempt to get security by short symbol
            </summary>
            <param name="sym"></param>
            <param name="sec"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BasketImpl.TryGetSecurityAnySymbol(System.String,Prac.API.Security@)">
            <summary>
            try to fetch security using long then short symbol
            </summary>
            <param name="sym"></param>
            <param name="sec"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BasketImpl.Add(Prac.API.Basket)">
            <summary>
            adds contents of another basket to this one.
            will not result in duplicate symbols
            </summary>
            <param name="mb"></param>
        </member>
        <member name="M:Prac.Core.BasketImpl.Remove(Prac.API.Basket)">
            <summary>
            removes all elements of baskets that match.
            unmatching elements are ignored
            </summary>
            <param name="mb"></param>
        </member>
        <member name="M:Prac.Core.BasketImpl.Remove(System.String)">
            <summary>
            remove single symbol from basket
            </summary>
            <param name="symbol"></param>
        </member>
        <member name="M:Prac.Core.BasketImpl.Remove(System.Int32)">
            <summary>
            remove index of a particular symbol
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:Prac.Core.BasketImpl.Remove(Prac.API.Security)">
            <summary>
            remove security from basket
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:Prac.Core.BasketImpl.Clear">
            <summary>
            empty basket
            </summary>
        </member>
        <member name="M:Prac.Core.BasketImpl.RemoveDupe(Prac.API.Basket)">
            <summary>
            removes duplicate symbols
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BasketImpl.NYSE(System.String)">
            <summary>
            gets nyse symbols
            </summary>
            <param name="ParseStocks"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BasketImpl.NASDAQ(System.String)">
            <summary>
            gets nasdaq symbols
            </summary>
            <param name="ParseStocks"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BasketImpl.LinkedOnlyNYSE(System.String)">
            <summary>
            gets clickable symbols found in a string (eg html)
            </summary>
            <param name="parsestring"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BasketImpl.LinkedOnlyNASDAQ(System.String)">
            <summary>
            gets clickable nasdaq symbols found in a string (eg html)
            </summary>
            <param name="parsestring"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.BasketImpl.Name">
            <summary>
            name of basket
            </summary>
        </member>
        <member name="M:Prac.Core.SendorderTracker.#ctor(Prac.API.PracClient,System.Int32)">
            <summary>
            provide the estimated # of symbols and the client to use
            </summary>
            <param name="tl"></param>
            <param name="estSymbols"></param>
        </member>
        <member name="M:Prac.Core.SendorderTracker.Start">
            <summary>
            start the tracker, required to process orders
            </summary>
        </member>
        <member name="M:Prac.Core.SendorderTracker.Stop">
            <summary>
            stop the tracker, required upon closing application
            </summary>
        </member>
        <member name="M:Prac.Core.SendorderTracker.sendorder(Prac.API.Order)">
            <summary>
            send order and track it
            </summary>
            <param name="o"></param>
        </member>
        <member name="P:Prac.Core.SendorderTracker.Wait">
            <summary>
            Milliseconds to wait after all items have been processed, before processing new items
            </summary>
        </member>
        <member name="P:Prac.Core.SendorderTracker.SubscribePause">
            <summary>
            milliseconds to pause after subscribing to a new symbol
            (assuming SubscribeSymbol is enabled)
            </summary>
        </member>
        <member name="P:Prac.Core.SendorderTracker.SubscribeBeforeSend">
            <summary>
            auto-subscribe to symbols before sending orders
            </summary>
        </member>
        <member name="P:Prac.Core.SendorderTracker.ResendOnError">
            <summary>
            resend order on any error
            </summary>
        </member>
        <member name="P:Prac.Core.SendorderTracker.ResendOnSelectError">
            <summary>
            resend only on selected errors
            </summary>
        </member>
        <member name="P:Prac.Core.SendorderTracker.SelectedErrors">
            <summary>
            specify a list of error codes whereby orders will quality to be resent
            </summary>
        </member>
        <member name="E:Prac.Core.SendorderTracker.SendDebugEvent">
            <summary>
            receive debug notifications from this component
            </summary>
        </member>
        <member name="P:Prac.Core.SendorderTracker.MarketBasket">
            <summary>
            get or set the current market basket of this component
            </summary>
        </member>
        <member name="E:Prac.Core.SendorderTracker.OrderIdStatusEvent">
            <summary>
            sends status of an order
            </summary>
        </member>
        <member name="P:Prac.Core.SendorderTracker.WaitItem">
            <summary>
            Milliseconds to wait between processing each queue item
            </summary>
        </member>
        <member name="T:Prac.Core.Util">
            <summary>
            Utility class holding commonly used properties for PracCore
            </summary>
        </member>
        <member name="F:Prac.Core.Util.PROGRAM">
            <summary>
            official program name of the core
            </summary>
        </member>
        <member name="M:Prac.Core.Util.exists(System.String)">
            <summary>
            test if a local file exists
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.TryParseEnum``1(System.String,``0@)">
            <summary>
            .net 3.5 equivalent of Enum.TryPrase
            </summary>
            <typeparam name="TEnum"></typeparam>
            <param name="value"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.sleep(System.Int32)">
            <summary>
            sleep current thread a few milliseconds
            </summary>
            <param name="ms"></param>
        </member>
        <member name="M:Prac.Core.Util.openurl(System.String)">
            <summary>
            opens a url 
            </summary>
            <param name="url"></param>
        </member>
        <member name="M:Prac.Core.Util.openurl(System.String,Prac.API.DebugDelegate)">
            <summary>
            opens a url
            </summary>
            <param name="url"></param>
            <param name="d"></param>
        </member>
        <member name="M:Prac.Core.Util.isnullorws(System.String)">
            <summary>
            .net 35 equivalnet of string.IsNullEmptyOrWhiteSpace
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.geturl(System.String,Prac.API.DebugDelegate)">
            <summary>
            gets a url
            </summary>
            <param name="url"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.geturl(System.String,System.Boolean,Prac.API.DebugDelegate)">
            <summary>
            gets a url
            </summary>
            <param name="url"></param>
            <param name="nocache"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.ProgramData(System.String)">
            <summary>
            gets folder where data for a given program should reside
            </summary>
            <param name="PROGRAM"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.PCD2DT(System.Int32)">
            <summary>
            Converts core date to DateTime (eg 20070926 to "DateTime.Mon = 9, DateTime.Day = 26, DateTime.ShortDate = Sept 29, 2007"
            </summary>
            <param name="coreDate"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.PCT2DT(System.Int32)">
            <summary>
            Converts core Time to DateTime.  If not using seconds, put a zero.
            </summary>
            <param name="coreTime"></param>
            <param name="coreSec"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.PCT2DT(Prac.API.Tick)">
            <summary>
            gets datetime of a tick
            </summary>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.ToDateTime(System.Int32,System.Int32)">
            <summary>
            Converts core Date and Time format to a DateTime. 
            eg DateTime ticktime = ToDateTime(tick.date,tick.time);
            </summary>
            <param name="coreDate"></param>
            <param name="coreTime"></param>
            <param name="coreSec"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.DT2FT">
            <summary>
            gets fasttime/core time for now
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.DT2FT(System.DateTime)">
            <summary>
            converts datetime to fasttime format
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.PC2FT(System.Int32,System.Int32,System.Int32)">
            <summary>
            converts core time to fasttime
            </summary>
            <param name="hour"></param>
            <param name="min"></param>
            <param name="sec"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.PC2FT(Prac.API.Tick)">
            <summary>
            gets fasttime from a core tick
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.FTDIFF(System.Int32,System.Int32)">
            <summary>
            gets elapsed seconds between two fasttimes
            </summary>
            <param name="firsttime"></param>
            <param name="latertime"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.FT2FTS(System.Int32)">
            <summary>
            converts fasttime to fasttime span, or elapsed seconds
            </summary>
            <param name="fasttime"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.FTADD(System.Int32,System.Int32)">
            <summary>
            adds fasttime and fasttimespan (in seconds).  does not rollover 24hr periods.
            </summary>
            <param name="firsttime"></param>
            <param name="secondtime"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.FT2DT(System.Int32)">
            <summary>
            converts fasttime to a datetime
            </summary>
            <param name="ftime"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.Version2Build(System.Version)">
            <summary>
            converts a version to traditional glean build number
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.Version2String(System.Version)">
            <summary>
            convert version to string
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.ToPCDateTime">
            <summary>
            get long for current date + time
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.PCDT2PCD(System.Int64)">
            <summary>
            get a date from a datetime
            </summary>
            <param name="datetime"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.PCDT2PCT(System.Int64)">
            <summary>
            get a time from a datetime
            </summary>
            <param name="datetime"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.ToPCDateTime(System.Int32,System.Int32)">
            <summary>
            take a date and time and get a unified datetime
            </summary>
            <param name="date"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.ToPCDateTime(System.DateTime)">
            <summary>
            get long for date + time
            </summary>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.ToPCDate">
            <summary>
            gets core date for today
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.ToPCDate(System.DateTime)">
            <summary>
            Converts a DateTime to core Date (eg July 11, 2006 = 20060711)
            </summary>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.ToPCDate(System.Int64)">
            <summary>
            Converts a DateTime.Ticks values to pcdate (eg 8million milliseconds since 1970 ~= 19960101 (new years 1996)
            </summary>
            <param name="DateTimeTicks"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.ToPCTime">
            <summary>
            gets core time for now
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.ToPCTime(System.DateTime)">
            <summary>
            gets core time from date
            </summary>
            <param name="date"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.PCDateSplit(System.Int32)">
            <summary>
            Converts a pcdate integer format into an array of ints
            </summary>
            <param name="fulltime">The fulltime.</param>
            <returns>int[3] { year, month, day}</returns>
        </member>
        <member name="M:Prac.Core.Util.PCDateMatch(System.Int32,System.Int32,Prac.Core.DateMatchType)">
            <summary>
            Tests if two dates are the same, given a mask as DateMatchType.
            
            ie, 20070605 will match 20070705 if DateMatchType is Day or Year.
            </summary>
            <param name="fulldate">The fulldate in pcdate format (int).</param>
            <param name="matchdate">The matchdate to test against (int).</param>
            <param name="dmt">The "mask" that says what to pay attention to when matching.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.CleanVer(System.String)">
            <summary>
            Obtains a version out of a string that contains version + other information.
            </summary>
            <param name="ver">string containing version</param>
            <returns>version number</returns>
        </member>
        <member name="M:Prac.Core.Util.isEarlyClose(System.Int32)">
            <summary>
            Provide date in pcdate format, returns whether market (NYSE) closes early on this day.
            </summary>
            <param name="today"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.GetEarlyClose(System.Int32)">
            <summary>
            Gets early close time for a given date.   Returns zero if not an early close.
            </summary>
            <param name="today"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.FillsToText(System.Collections.Generic.List{Prac.Core.TradeImpl},System.Char,System.String)">
            <summary>
            Converts list of trades to a delimited file readable by excel, R, matlab, google spreadsheets, etc.
            </summary>
            <param name="stocktrades"></param>
            <param name="delimiter"></param>
            <param name="filepath"></param>
        </member>
        <member name="M:Prac.Core.Util.TradesToClosedPL(Prac.API.Trade)">
            <summary>
            converts a trade to an array of comma-delimited string data also containing closedPL, suitable for output to file for reading by excel, R, matlab, etc.
            </summary>
            <param name="trade"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.TradesToClosedPL(System.Collections.Generic.List{Prac.API.Trade})">
            <summary>
            Converts a list of trades to an array of comma-delimited string data also containing closedPL, suitable for output to file for reading by excel, R, matlab, etc.
            </summary>
            <param name="tradelist"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.TradesToClosedPL(System.Collections.Generic.List{Prac.API.Trade},System.Char)">
            <summary>
            Converts a list of trades to an array of delimited string data also containing closedPL, suitable for output to file for reading by excel, R, matlab, etc.
            </summary>
            <param name="tradelist"></param>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.ClosedPLToText(System.Collections.Generic.List{Prac.API.Trade},System.Char,System.String)">
            <summary>
            Converts a list of trades to delimited text file containing closedPL, suitable for reading by excel, R, matlab, etc.
            </summary>
            <param name="tradelist"></param>
            <param name="delimiter"></param>
            <param name="filepath"></param>
        </member>
        <member name="M:Prac.Core.Util.PrettyError(Prac.API.Providers,System.Int32)">
            <summary>
            Gets a user-friendly string for Broker and core error messages.
            </summary>
            <param name="errorcode">The errorcode.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.TickFileIndex(System.String)">
            <summary>
            gets list of readable tickfiles in top level of a folder.
            2nd dimension of list is size of file in bytes (as string)
            </summary>
            <param name="folder"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.TickFileIndex(System.String,System.String)">
            <summary>
            builds list of readable tick files with given extension found in top level of folder
            </summary>
            <param name="Folder"></param>
            <param name="tickext"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.TickFileIndex(System.String,System.String,System.Boolean)">
            <summary>
            builds list of readable tickfiles found in given folder
            </summary>
            <param name="Folder">path containing tickfiles</param>
            <param name="tickext">file extension</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.TickFileIndex(System.String,System.String,System.Boolean,Prac.API.DebugDelegate)">
            <summary>
            builds list of readable tickfiles (and their byte-size) found in folder
            </summary>
            <param name="Folder"></param>
            <param name="tickext"></param>
            <param name="searchSubFolders"></param>
            <param name="debug"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.DumpObjectProperties(System.Object)">
            <summary>
            dumps public properties and fields of an object as an xml string
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.DumpObjectProperties(System.Object,Prac.API.DebugDelegate)">
            <summary>
            dumps public properties and fields as xml string, with optional debugging for errors
            </summary>
            <param name="o"></param>
            <param name="deb"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.ProgramCount(System.String)">
            <summary>
            
            </summary>
            <param name="PROGRAM"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.Serialize``1(``0)">
            <summary>
            convert any structure/type to a string (can be converted back using Deserialize)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.Serialize``1(``0,Prac.API.DebugDelegate)">
            <summary>
            convert any structure/type to a string (can be converted back using Deserialize)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="o"></param>
            <param name="debug"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.Serialize``1(``0,System.Boolean,Prac.API.DebugDelegate)">
            <summary>
            convert any structure/type to a string (can be converted back using Deserialize)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="o"></param>
            <param name="compress"></param>
            <param name="debug"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.Deserialize``1(System.String)">
            <summary>
            deserialize a structure/type from a string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.Deserialize``1(System.String,Prac.API.DebugDelegate)">
            <summary>
            deserialize a structure/type from a string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="msg"></param>
            <param name="debug"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.Deserialize``1(System.String,System.Boolean,Prac.API.DebugDelegate)">
            <summary>
            deserialize a structure/type from a string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="msg"></param>
            <param name="uncompress"></param>
            <param name="debug"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.ToFile``1(``0,System.String)">
            <summary>
            create an xml file from any data structure (can be restored with FromFile)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="o"></param>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.ToFile``1(``0,System.String,Prac.API.DebugDelegate)">
            <summary>
            create an xml file from any data structure (can be restored with FromFile)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="o"></param>
            <param name="file"></param>
            <param name="debug"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.FromFile``1(System.String,``0@)">
            <summary>
            restore data structure(s) from a file (created with ToFile)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="file"></param>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Util.FromFile``1(System.String,``0@,Prac.API.DebugDelegate)">
            <summary>
            restore data structure(s) from a file (created with ToFile)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="file"></param>
            <param name="o"></param>
            <param name="debug"></param>
            <returns></returns>
        </member>
        <member name="T:Prac.Core.SecurityImpl">
            <summary>
            used to hold and work with securities.
            Supported Securities : Stocks, Futures, Forex.
            Options, Bonds, Swaps, etc are supported on certain brokers.
            </summary>
        </member>
        <member name="M:Prac.Core.SecurityImpl.#ctor(System.String,System.String,Prac.API.SecurityType)">
            <summary>
            create new security
            </summary>
            <param name="sym"></param>
            <param name="exchange"></param>
            <param name="type"></param>
        </member>
        <member name="M:Prac.Core.SecurityImpl.#ctor(Prac.API.Security)">
            <summary>
            clone a security
            </summary>
            <param name="copy"></param>
        </member>
        <member name="M:Prac.Core.SecurityImpl.#ctor">
            <summary>
            create new security
            </summary>
        </member>
        <member name="M:Prac.Core.SecurityImpl.#ctor(System.String)">
            <summary>
            create new security
            </summary>
            <param name="sym"></param>
        </member>
        <member name="M:Prac.Core.SecurityImpl.#ctor(System.String,Prac.API.SecurityType)">
            <summary>
            create new security
            </summary>
            <param name="sym"></param>
            <param name="type"></param>
        </member>
        <member name="M:Prac.Core.SecurityImpl.ToString">
            <summary>
            printable string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.SecurityImpl.Serialize(Prac.API.Security)">
            <summary>
            serialize security as a string
            </summary>
            <param name="sec"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.SecurityImpl.Parse(System.String)">
            <summary>
            get a security from a user-specified string
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.SecurityImpl.Parse(System.String,System.Int32)">
            <summary>
            get a security form a user-specified string
            </summary>
            <param name="msg"></param>
            <param name="date"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.SecurityImpl.ParseOptionOSI(System.String,Prac.API.Security@)">
            <summary>
            infer option security information from OSI string
            http://biz.yahoo.com/opt/symbol.html
            </summary>
            <param name="osi"></param>
            <param name="sec"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.SecurityImpl.Deserialize(System.String)">
            <summary>
            deserialize a security from a string
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="F:Prac.Core.SecurityImpl.HistSource">
            <summary>
            historical source of tick data for security
            </summary>
        </member>
        <member name="M:Prac.Core.SecurityImpl.NextTick">
            <summary>
            Fetches next historical tick for stock, or invalid tick if no historical data is available.
            </summary>
        </member>
        <member name="M:Prac.Core.SecurityImpl.FromTIK(System.String)">
            <summary>
            load a security from a historical tick file
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.SecurityImpl.Equals(System.Object)">
            <summary>
            test whether two securities are equal
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.SecurityImpl.SecurityFromFileName(System.String)">
            <summary>
            determine security from the filename, without opening file
            (use SecurityImpl.FromFile to actually read it in)
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.SecurityImpl.hasType">
            <summary>
            whether security has a defined security type
            </summary>
        </member>
        <member name="P:Prac.Core.SecurityImpl.symbol">
            <summary>
            symbol associated with security
            </summary>
        </member>
        <member name="P:Prac.Core.SecurityImpl.symbol_Spaces">
            <summary>
            symbol with underscores represented as spaces
            </summary>
        </member>
        <member name="P:Prac.Core.SecurityImpl.Name">
            <summary>
            name (symbol) of security
            </summary>
        </member>
        <member name="P:Prac.Core.SecurityImpl.DestEx">
            <summary>
            exchange associated with security
            </summary>
        </member>
        <member name="P:Prac.Core.SecurityImpl.Type">
            <summary>
            type of security
            </summary>
        </member>
        <member name="P:Prac.Core.SecurityImpl.isValid">
            <summary>
            whether security is valid
            </summary>
        </member>
        <member name="P:Prac.Core.SecurityImpl.hasDest">
            <summary>
            whether security has a exchange
            </summary>
        </member>
        <member name="P:Prac.Core.SecurityImpl.FullName">
            <summary>
            full name of security including all options
            </summary>
        </member>
        <member name="P:Prac.Core.SecurityImpl.Details">
            <summary>
            details of security (eg PUT/CALL for options)
            </summary>
        </member>
        <member name="P:Prac.Core.SecurityImpl.Strike">
            <summary>
            strike price for options
            </summary>
        </member>
        <member name="P:Prac.Core.SecurityImpl.Date">
            <summary>
            date associated with security
            </summary>
        </member>
        <member name="P:Prac.Core.SecurityImpl.hasHistorical">
            <summary>
            Says whether stock contains historical data.
            </summary>
        </member>
        <member name="P:Prac.Core.SecurityImpl.ApproxTicks">
            <summary>
            approximate # of ticks contained in historical security
            </summary>
        </member>
        <member name="T:Prac.Core.ScreenCapture">
            <summary>
            Provides functions to capture the entire screen, or a particular window, and save it to a file.
            </summary>
        </member>
        <member name="M:Prac.Core.ScreenCapture.CaptureScreen">
            <summary>
            Creates an Image object containing a screen shot of the entire desktop
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.ScreenCapture.CaptureWindow(System.IntPtr)">
            <summary>
            Creates an Image object containing a screen shot of a specific window
            </summary>
            <param name="handle">The handle to the window. (In windows forms, this is obtained by the Handle property)</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.ScreenCapture.CaptureWindowToFile(System.IntPtr,System.String,System.Drawing.Imaging.ImageFormat)">
            <summary>
            Captures a screen shot of a specific window, and saves it to a file
            </summary>
            <param name="handle"></param>
            <param name="filename"></param>
            <param name="format"></param>
        </member>
        <member name="M:Prac.Core.ScreenCapture.CaptureScreenToFile(System.String,System.Drawing.Imaging.ImageFormat)">
            <summary>
            Captures a screen shot of the entire desktop, and saves it to a file
            </summary>
            <param name="filename"></param>
            <param name="format"></param>
        </member>
        <member name="T:Prac.Core.ScreenCapture.GDI32">
            <summary>
            Helper class containing Gdi32 API functions
            </summary>
        </member>
        <member name="T:Prac.Core.ScreenCapture.User32">
            <summary>
            Helper class containing User32 API functions
            </summary>
        </member>
        <member name="T:Prac.Core.LimitOrder">
            <summary>
            Create limit orders.
            </summary>
        </member>
        <member name="T:Prac.Core.BuyLimit">
            <summary>
            Create buy limit orders.
            </summary>
        </member>
        <member name="T:Prac.Core.SellLimit">
            <summary>
            Create sell-limit orders.
            </summary>
        </member>
        <member name="T:Prac.Core.BuyOPG">
            <summary>
            Create a buy OPG order
            </summary>
        </member>
        <member name="T:Prac.Core.OrderTracker">
            <summary>
            track status of orders
            </summary>
        </member>
        <member name="M:Prac.Core.OrderTracker.GetEnumerator">
            <summary>
            get orders from tracker
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OrderTracker.#ctor">
            <summary>
            create a tracker
            </summary>
        </member>
        <member name="M:Prac.Core.OrderTracker.isPending(System.Int64)">
            <summary>
            see if an order was pending
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OrderTracker.isCompleted(System.Int64)">
            <summary>
            see if an order was completely filled
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OrderTracker.isCanceled(System.Int64)">
            <summary>
            see if order was canceled
            </summary>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OrderTracker.Sent(System.Int64)">
            <summary>
            returns sent size of an order
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OrderTracker.Filled(System.Int64)">
            <summary>
            returns filled size of an order
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OrderTracker.SentOrder(System.Int64)">
            <summary>
            gets entire sent order
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OrderTracker.isTracked(System.Int64)">
            <summary>
            returns true if order is known to tracker
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.OrderTracker.id">
            <summary>
            numerical id of this tracker
            </summary>
        </member>
        <member name="P:Prac.Core.OrderTracker.smallid">
            <summary>
            integer version of tracker id
            </summary>
        </member>
        <member name="P:Prac.Core.OrderTracker.Item(System.Int32)">
            <summary>
            get unfilled portion of order from index
            </summary>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.OrderTracker.Item(System.Int64)">
            <summary>
            get unfilled portion of order from order id
            </summary>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.REGSHO_ShortTracker.isOrderShort(Prac.API.Order)">
            <summary>
            returns true if order is a true short
            (versus a sell/buy)
            </summary>
            <param name="ord"></param>
            <returns></returns>
        </member>
        <member name="T:Prac.Core.eSigTick">
            <summary>
            Marshalls eSignal-specific tickdata into and out of the generic Tick type.
            </summary>
        </member>
        <member name="M:Prac.Core.eSigTick.FromStream(System.String,System.IO.StreamReader)">
            <summary>
            Loads a tick straight from an EPF file in the form of a StreamReader
            </summary>
            <param name="symbol">The symbol.</param>
            <param name="sr">The sr.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.eSigTick.ToEPF(Prac.API.Tick)">
            <summary>
            Converts the tick to a string-equivalent that can be written to an EPF file.
            </summary>
            <param name="t">The t.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.eSigTick.EPFheader(System.String,System.Int32)">
            <summary>
            Create an epf file header.
            </summary>
            <param name="stock">The securities symbol</param>
            <param name="date">The date</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.eSigTick.EPFheader(System.String,System.Int32,System.Int32)">
            <summary>
            Create an epf file header for a range of dates.
            </summary>
            <param name="stock">The securities symbol</param>
            <param name="date1">The opening date</param>
            <param name="date2">The closing date</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.eSigTick.EPFheader(Prac.Core.SecurityImpl)">
            <summary>
            Create an epf file header
            </summary>
            <param name="sec">The security</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.eSigTick.InitEpf(System.IO.StreamReader)">
            <summary>
            Initilize the reading of an EPF file and return the header as a Stock object.
            </summary>
            <param name="EPFfile">The EP ffile.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.CSVInitGeneric``1(System.String,Prac.API.GenericTracker{``0}@)">
            <summary>
            import a csv file into a generic tracker
            </summary>
            <typeparam name="T"></typeparam>
            <param name="csvfile"></param>
            <param name="gt"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.CSVInitGeneric``1(System.String,Prac.API.GenericTracker{``0}@,``0)">
            <summary>
            import a csv file into a generic tracker
            </summary>
            <typeparam name="T"></typeparam>
            <param name="csvfile"></param>
            <param name="gt"></param>
            <param name="coldefault"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.CSVInitGeneric``1(System.String,System.Boolean,Prac.API.GenericTracker{``0}@,System.Int32,``0)">
            <summary>
            import a csv file into a generic tracker
            </summary>
            <typeparam name="T"></typeparam>
            <param name="csvfile"></param>
            <param name="hasheader"></param>
            <param name="gt"></param>
            <param name="symcol"></param>
            <param name="coldefault"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.CSVInitGeneric``1(System.String,System.Boolean,Prac.API.GenericTracker{``0}@,System.Int32,``0,System.Char)">
            <summary>
            import a csv file into a generic tracker
            </summary>
            <typeparam name="T"></typeparam>
            <param name="csvfile"></param>
            <param name="hasheader"></param>
            <param name="gt"></param>
            <param name="symcol"></param>
            <param name="coldefault"></param>
            <param name="delim"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.CSVCOL2Generic``1(System.String,System.Boolean,Prac.API.GenericTracker{``0}@,System.Int32,System.Int32,System.Char,Prac.API.DebugDelegate)">
            <summary>
            import csv column to a generic tracker value
            </summary>
            <typeparam name="T"></typeparam>
            <param name="csvfile"></param>
            <param name="hasheader"></param>
            <param name="gt"></param>
            <param name="symcol"></param>
            <param name="col"></param>
            <param name="coldefaultOnFail"></param>
            <param name="delim"></param>
            <param name="debug"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.CSV2GTS(System.String,Prac.API.GenericTrackerI[])">
            <summary>
            autopopulate a list of generics from a csv file (assuming primary column: SYMBOL)
            </summary>
            <param name="csvfile"></param>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.CSV2GTS(System.String,Prac.API.DebugDelegate,Prac.API.GenericTrackerI[])">
            <summary>
            autopopulate a list of generics from a csv file (assuming primary column: SYMBOL)
            </summary>
            <param name="csvfile"></param>
            <param name="d"></param>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.CSV2GTS(System.String,System.String,Prac.API.DebugDelegate,Prac.API.GenericTrackerI[])">
            <summary>
            autopopulate a list of generics from a csv file
             * csv needs a header file
             * csv must have a primary column (typically titled SYMBOL)
             * generics should be listed in same order as csv columns
             * provide name of the primary column if it's something other than SYMBOL
            </summary>
            <param name="csvfile"></param>
            <param name="primarygtname"></param>
            <param name="d"></param>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.WriteCSV``1(System.String,Prac.API.GenericTracker{``0},System.Int32)">
            <summary>
            write a generic tracker to one column of a csv file, leaving rest of file untouched.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filepath"></param>
            <param name="gt"></param>
            <param name="col"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.WriteCSV``1(System.String,Prac.API.GenericTracker{``0},System.Int32,System.Int32)">
            <summary>
            write a generic tracker to one column of a csv file, leaving rest of file untouched.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filepath"></param>
            <param name="gt"></param>
            <param name="col"></param>
            <param name="symcol"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.WriteCSV``1(System.String,Prac.API.GenericTracker{``0},System.Int32,System.Int32,System.Boolean)">
            <summary>
            write a generic tracker to one column of a csv file, leaving rest of file untouched.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filepath"></param>
            <param name="gt"></param>
            <param name="col"></param>
            <param name="symcol"></param>
            <param name="hasheader"></param>
            <param name="delim"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.WriteCSV``1(System.String,Prac.API.GenericTracker{``0},System.Int32,System.Int32,System.Boolean,System.Char)">
            <summary>
            write a generic tracker to one column of a csv file, leaving rest of file untouched.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filepath"></param>
            <param name="gt"></param>
            <param name="col"></param>
            <param name="symcol"></param>
            <param name="hasheader"></param>
            <param name="delim"></param>
            <param name="stringformat"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.WriteCSV``1(System.String,Prac.API.GenericTracker{``0},System.Int32,System.Int32,System.Boolean,System.Char,System.String)">
            <summary>
            write a generic tracker to one column of a csv file, leaving rest of file untouched.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filepath"></param>
            <param name="gt"></param>
            <param name="col"></param>
            <param name="symcol"></param>
            <param name="hasheader"></param>
            <param name="delim"></param>
            <param name="stringformat"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.WriteCSV``1(System.String,Prac.API.GenericTracker{``0},System.Int32,System.Int32,System.Boolean,System.Char,System.String,Prac.API.DebugDelegate)">
            <summary>
            write a generic tracker to one column of a csv file, leaving rest of file untouched.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filepath"></param>
            <param name="gt"></param>
            <param name="col"></param>
            <param name="symcol"></param>
            <param name="hasheader"></param>
            <param name="delim"></param>
            <param name="stringformat"></param>
            <param name="debug"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.InitCSV(System.String,Prac.API.GenericTrackerI[])">
            <summary>
            create a csv file using Name on each of an array of generic trackers
            </summary>
            <param name="filepath"></param>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.InitCSV(System.String,System.String[])">
            <summary>
            create a csv file
            </summary>
            <param name="filepath"></param>
            <param name="headers"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.InitCSV(System.String,System.String[],System.Boolean)">
            <summary>
            create a csv file
            </summary>
            <param name="filepath"></param>
            <param name="headers"></param>
            <param name="overwrite"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.InitCSV(System.String,System.String[],System.Boolean,System.Char)">
            <summary>
            create a csv file
            </summary>
            <param name="filepath"></param>
            <param name="headers"></param>
            <param name="overwrite"></param>
            <param name="delim"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTcsv.InitCSV(System.String,System.String[],System.Boolean,System.Char,Prac.API.DebugDelegate)">
            <summary>
            create a csv file
            </summary>
            <param name="filepath"></param>
            <param name="headers"></param>
            <param name="overwrite"></param>
            <param name="delim"></param>
            <param name="debug"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.BarHelper.LoadPreviousBars(System.Int32,System.String[],System.Boolean,Prac.Core.BarListTracker@,Prac.API.SymBarIntervalDelegate,Prac.API.DebugDelegate)">
            <summary>
            load previous days bar data from tick files located in tick folder
            </summary>
            <param name="PreviousDay"></param>
            <param name="syms"></param>
            <param name="AttemptToLoadPreviousDayBars"></param>
            <param name="_blt"></param>
            <param name="NewBarEvents"></param>
            <param name="deb"></param>
            <returns></returns>
        </member>
        <member name="T:Prac.Core.MarketOrder">
            <summary>
            Create market orders.
            </summary>
        </member>
        <member name="T:Prac.Core.BuyMarket">
            <summary>
            Create buy market orders.
            </summary>
        </member>
        <member name="T:Prac.Core.SellMarket">
            <summary>
            Create sell market orders.
            </summary>
        </member>
        <member name="T:Prac.Core.ImbalanceImpl">
            <summary>
            receive imbalance information 
            </summary>
        </member>
        <member name="T:Prac.Core.IdTracker">
            <summary>
            used to obtain valid ids for orders, responses, etc
            </summary>
        </member>
        <member name="F:Prac.Core.IdTracker.MaxNamedAssigns">
            <summary>
            number of unique ids (per symbol) that can be returned from a named assignment
            </summary>
        </member>
        <member name="F:Prac.Core.IdTracker.isMagicIdOnMaxName">
            <summary>
            otherwise the same id is returned
            </summary>
        </member>
        <member name="M:Prac.Core.IdTracker.#ctor">
            <summary>
            creates an object to assign unique order ids
            </summary>
        </member>
        <member name="M:Prac.Core.IdTracker.#ctor(System.Int64)">
            <summary>
            creates an object to assign unique ids
            </summary>
            <param name="OwnerId"></param>
        </member>
        <member name="M:Prac.Core.IdTracker.#ctor(System.Boolean,System.Int64,System.Int64)">
            <summary>
            creates an object to assign unique order ids to one or more owners.
            </summary>
            <param name="OwnerId">A unique number identifying this owner</param>
            <param name="initialId">Owners first order id</param>
        </member>
        <member name="M:Prac.Core.IdTracker.getidname(System.Int64)">
            <summary>
            gets an id name from an order id
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.IdTracker.getsym(System.Int64)">
            <summary>
            gets a symbol from an order id
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.IdTracker.getname(System.Int64)">
            <summary>
            gets an order name from order id
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.IdTracker.AssignCount(System.String,System.String)">
            <summary>
            get count of assignments from symbol and name
            </summary>
            <param name="idname"></param>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.IdTracker.AssignCount(System.String)">
            <summary>
            get count of assignments from this name
            </summary>
            <param name="idname"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.IdTracker.getidname(System.String,System.String)">
            <summary>
            gets an id name for a symbol
            </summary>
            <param name="sym"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.IdTracker.getname(System.String)">
            <summary>
            gets name from id name
            </summary>
            <param name="idname"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.IdTracker.getsym(System.String)">
            <summary>
            gets symbol from idname
            </summary>
            <param name="idname"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.IdTracker.idname(System.String,System.String)">
            <summary>
            gets a id name for a symbol
            </summary>
            <param name="sym"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.IdTracker.namedid(System.String,System.String)">
            <summary>
            get last id assigned to this name
            </summary>
            <param name="sym"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.IdTracker.Clear">
            <summary>
            clear all named ids
            (subsequent ids will still be unique from previous)
            </summary>
        </member>
        <member name="P:Prac.Core.IdTracker.AssignId">
            <summary>
            obtains a new id permanently
            </summary>
        </member>
        <member name="P:Prac.Core.IdTracker.NextId">
            <summary>
            provides what next id will be without assigning it
            </summary>
        </member>
        <member name="P:Prac.Core.IdTracker.NextOverflows">
            <summary>
            return true if next id will overflow
            </summary>
        </member>
        <member name="P:Prac.Core.IdTracker.Item(System.String,System.String)">
            <summary>
            get a current id name by symbol
            </summary>
            <param name="sym"></param>
            <param name="idname"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.IdTracker.Item(System.Int32,System.String)">
            <summary>
            get a current idname by number
            </summary>
            <param name="idx"></param>
            <param name="idname"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.IdTracker.Item(System.String)">
            <summary>
            get or set current id by name.
            NOTE : generally you will want to call this with a symbol,
            EG idt["IBM","my entry market"]
            
            otherwise called like :
            (eg idt["myentrymkt"], idt["myentrylmt"], idt["myexitprofit"])
            Set name to zero to force reset on next use.
            </summary>
            <param name="idname"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.addindex(System.String,Prac.API.GenericTrackerI[])">
            <summary>
            gets index for a symbol in a list of generics, adding default value in every generic if symbol is not indexed
            </summary>
            <param name="sym"></param>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.addindex(System.String,Prac.API.TextIdxDelegate,Prac.API.GenericTrackerI[])">
            <summary>
            gets index for a symbol in a list of generics, adding default if not indexed yet.  provides callback for post processing on new symbols.
            </summary>
            <param name="sym"></param>
            <param name="postaddcallback"></param>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.index(System.String[],Prac.API.GenericTrackerI[])">
            <summary>
            index a list of generic trackers using a list of symbols as labels
            </summary>
            <param name="syms"></param>
            <param name="gts"></param>
        </member>
        <member name="M:Prac.Core.GTHelper.index(System.String[],System.Boolean,Prac.API.GenericTrackerI[])">
            <summary>
            index a list of generic trackers using a list of symbols as labels
            </summary>
            <param name="syms"></param>
            <param name="skipifindexed"></param>
            <param name="gts"></param>
        </member>
        <member name="M:Prac.Core.GTHelper.index(System.String[],System.Boolean,Prac.API.TextIdxDelegate,Prac.API.GenericTrackerI[])">
            <summary>
            index a list of generic trackers using a list of symbols as labels
            </summary>
            <param name="syms"></param>
            <param name="skipifindexed"></param>
            <param name="newtxt"></param>
            <param name="gts"></param>
        </member>
        <member name="M:Prac.Core.GTHelper.getsymbollist(Prac.API.GenericTrackerI[])">
            <summary>
            gets labels/symbols identified in first generictracker in a list of generics
            </summary>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.RemoveLabels(Prac.API.GenericTrackerI@,System.String[])">
            <summary>
            remove labels from a generic tracker
            (executes a copy that excludes desired labels)
            </summary>
            <param name="gt"></param>
            <param name="removelabs"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.GetIndicatorNames(Prac.API.GenericTrackerI[])">
            <summary>
            gets indicator names from trackers
            </summary>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.GetIndicatorValues(System.Int32,Prac.API.GenericTrackerI[])">
            <summary>
            gets indicator values from trackers
            </summary>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.GetIndicatorValues(System.String,Prac.API.GenericTrackerI[])">
            <summary>
            gets indicator values from trackers
            </summary>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.GetIndicatorPrettyPairs(System.String,Prac.API.GenericTrackerI[])">
            <summary>
            get name=>value pairs
            </summary>
            <param name="txt"></param>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.GetIndicatorPrettyPairs(System.String,System.String,Prac.API.GenericTrackerI[])">
            <summary>
            get name=>value pairs
            </summary>
            <param name="txt"></param>
            <param name="delim"></param>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.GetIndicatorPrettyPairs(System.Int32,Prac.API.GenericTrackerI[])">
            <summary>
            get name=>value pairs
            </summary>
            <param name="idx"></param>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.GetIndicatorPrettyPairs(System.Int32,System.String,Prac.API.GenericTrackerI[])">
            <summary>
            get name=>value pairs
            </summary>
            <param name="idx"></param>
            <param name="delim"></param>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.GetIndicatorPairs(Prac.API.GenericTrackerI[])">
            <summary>
            gets all current values of every tracker for every symbol being tracked
            </summary>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.GetIndicatorPairs(System.Int32,Prac.API.GenericTrackerI[])">
            <summary>
            get single readable line of indicators for output when response debugging
            </summary>
            <param name="idx"></param>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.GetIndicatorPairs(System.Int32,System.String,Prac.API.GenericTrackerI[])">
            <summary>
            get single readable line of indicators (with custom delimiter) for output when response debugging
            </summary>
            <param name="idx"></param>
            <param name="delim"></param>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.isGTsOk(Prac.API.GenericTrackerI[])">
            <summary>
            tells you whether many gts are ok
            </summary>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.isGTsOk(Prac.API.DebugDelegate,Prac.API.GenericTrackerI[])">
            <summary>
            tells you whether many gts are ok
            </summary>
            <param name="gts"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.JoinGT(Prac.API.GenericTracker{System.Decimal})">
            <summary>
            join tracker values into space delimited ones
            </summary>
            <param name="gt"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.JoinGT(Prac.API.GenericTracker{System.Decimal},System.String,System.Boolean,System.String,System.String)">
            <summary>
            joint tracker values
            </summary>
            <param name="gt"></param>
            <param name="valfmt"></param>
            <param name="showlabels"></param>
            <param name="labdelim"></param>
            <param name="itemdelim"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.SerializeGT``1(System.String@,Prac.API.GenericTracker{``0},Prac.API.DebugDelegate)">
            <summary>
            serialize a gt
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="gt"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.DeserializeGT``1(System.String,Prac.API.GenericTracker{``0}@,Prac.API.DebugDelegate)">
            <summary>
            deserialize a gt
            </summary>
            <typeparam name="T"></typeparam>
            <param name="gtdata"></param>
            <param name="gt"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.GetDateIdxBefore``1(Prac.API.GenericTracker{``0},System.DateTime)">
            <summary>
            in date tracked gt, get index before a given date
            </summary>
            <typeparam name="T"></typeparam>
            <param name="gt"></param>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.GetDateIdxBefore(System.Collections.Generic.List{System.DateTime},System.DateTime)">
            <summary>
            get date index from a list
            </summary>
            <param name="gt"></param>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.GetDateIdxAfter``1(Prac.API.GenericTracker{``0},System.DateTime)">
            <summary>
            in date tracked gt, get index after a given date
            </summary>
            <typeparam name="T"></typeparam>
            <param name="gt"></param>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.DateLabel2Date``1(Prac.API.GenericTracker{``0},System.Int32)">
            <summary>
            convert a gt label to a date
            </summary>
            <typeparam name="T"></typeparam>
            <param name="gt"></param>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.DateLabelsToDates``1(Prac.API.GenericTracker{``0})">
            <summary>
            convert gt labels to dates
            </summary>
            <typeparam name="T"></typeparam>
            <param name="gt"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.GTHelper.DateLabelsToDates``1(Prac.API.GenericTracker{``0},System.Boolean)">
            <summary>
            convert gt labels to dates
            </summary>
            <typeparam name="T"></typeparam>
            <param name="gt"></param>
            <param name="insertbaddatesonerrors"></param>
            <returns></returns>
        </member>
        <member name="T:Prac.Core.Broker">
            <summary>
            A simulated broker class.
            Processes orders and fills them against external tick feed. (live or historical)
            </summary>
        </member>
        <member name="M:Prac.Core.Broker.CancelOrder(System.Int64)">
            <summary>
            cancel order from any account
            </summary>
            <param name="orderid"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Broker.CancelOrder(Prac.Core.Account,System.Int64)">
            <summary>
            cancel order for specific account only
            </summary>
            <param name="a"></param>
            <param name="orderid"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Broker.SendOrder(Prac.API.Order)">
            <summary>
            send order that is compatible with OrderDelegate events
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:Prac.Core.Broker.SendOrderStatus(Prac.API.Order)">
            <summary>
            Sends the order to the broker. (uses the default account)
            </summary>
            <param name="o">The order to be send.</param>
            <returns>status code</returns>
        </member>
        <member name="M:Prac.Core.Broker.SendOrderAccount(Prac.API.Order,Prac.Core.Account)">
            <summary>
            Sends the order to the broker for a specific account.
            </summary>
            <param name="o">The order to be sent.</param>
            <param name="a">the account to send with the order.</param>
            <returns>status code</returns>
        </member>
        <member name="F:Prac.Core.Broker.OPGEX">
            <summary>
            set to the exchange where opening prints are obtained from
            </summary>
        </member>
        <member name="M:Prac.Core.Broker.Execute(Prac.API.Tick)">
            <summary>
            Executes any open orders allowed by the specified tick.
            </summary>
            <param name="tick">The tick.</param>
            <returns>the number of orders executed using the tick.</returns>
        </member>
        <member name="M:Prac.Core.Broker.Reset">
            <summary>
            Resets this instance, clears all orders/trades/accounts held by the broker.
            </summary>
        </member>
        <member name="M:Prac.Core.Broker.GetTradeList(Prac.Core.Account)">
            <summary>
            Gets the complete execution list for this account
            </summary>
            <param name="a">account to request blotter from.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Broker.GetOrderList(Prac.Core.Account)">
            <summary>
            Gets the list of open orders for this account.
            </summary>
            <param name="a">Account.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Broker.GetOpenPosition(System.String)">
            <summary>
            Gets the open positions for the default account.
            </summary>
            <param name="symbol">The symbol to get a position for.</param>
            <returns>current position</returns>
        </member>
        <member name="M:Prac.Core.Broker.GetOpenPosition(System.String,Prac.Core.Account)">
            <summary>
            Gets the open position for the specified account.
            </summary>
            <param name="symbol">The symbol to get a position for.</param>
            <param name="a">the account.</param>
            <returns>current position</returns>
        </member>
        <member name="M:Prac.Core.Broker.GetClosedPL(System.String,Prac.Core.Account)">
            <summary>
            Gets the closed PL for a particular symbol and brokerage account.
            </summary>
            <param name="symbol">The symbol.</param>
            <param name="a">The Account.</param>
            <returns>Closed PL</returns>
        </member>
        <member name="M:Prac.Core.Broker.GetClosedPL(System.String)">
            <summary>
            Gets the closed PL for a particular symbol on the default account.
            </summary>
            <param name="symbol">The symbol.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Broker.GetClosedPL(Prac.Core.Account)">
            <summary>
            Gets the closed PL for an entire account. (all symbols)
            </summary>
            <param name="a">The account.</param>
            <returns>Closed PL</returns>
        </member>
        <member name="M:Prac.Core.Broker.GetClosedPL">
            <summary>
            Gets the closed PL for all symbols on the default account.
            </summary>
            <returns>Closed PL</returns>
        </member>
        <member name="M:Prac.Core.Broker.GetClosedPT(System.String,Prac.Core.Account)">
            <summary>
            Gets the closed points (points = PL on per-share basis) for given symbol/account.
            </summary>
            <param name="symbol">The symbol.</param>
            <param name="account">The account.</param>
            <returns>points</returns>
        </member>
        <member name="M:Prac.Core.Broker.GetClosedPT(System.String)">
            <summary>
            Gets the closed PT/Points for given symbol on default account.
            </summary>
            <param name="symbol">The symbol.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Broker.GetClosedPT(Prac.Core.Account)">
            <summary>
            Gets the closed Points on a specific account, all symbols.
            </summary>
            <param name="account">The account.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Broker.GetClosedPT">
            <summary>
            Gets the closed Points on the default account.
            </summary>
            <returns></returns>
        </member>
        <member name="E:Prac.Core.Broker.GotOrderCancelEvent">
            <summary>
            occurs when [got order cancel], response compatible
            </summary>
        </member>
        <member name="E:Prac.Core.Broker.GotOrderCancel">
            <summary>
            Occurs when [got order cancel].
            </summary>
        </member>
        <member name="E:Prac.Core.Broker.GotOrder">
            <summary>
            Occurs when [got order].
            </summary>
        </member>
        <member name="E:Prac.Core.Broker.GotFill">
            <summary>
            Occurs when [got fill].
            </summary>
        </member>
        <member name="P:Prac.Core.Broker.UseBidAskFills">
            <summary>
            whether bid/ask is used to fill orders.  if false, last trade is used.
            </summary>
        </member>
        <member name="P:Prac.Core.Broker.UseHighLiquidityFillsEOD">
            <summary>
            whether or not to assume high liquidity fills on sparse data.
            (should only be used on daily/EOD data)
            </summary>
        </member>
        <member name="P:Prac.Core.Broker.FillMode">
            <summary>
            Gets or sets the fill mode this broker uses when executing orders
            </summary>
        </member>
        <member name="T:Prac.Core.Calc">
            <summary>
            collection of calculations available 
            </summary>
        </member>
        <member name="M:Prac.Core.Calc.MidPoint(System.Single,System.Single)">
            <summary>
            calculate the middle between two values
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.MidPoint(System.Double,System.Double)">
            <summary>
            calculate the middle between two values
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.MidPoint(System.Decimal,System.Decimal)">
            <summary>
            calculate the middle between two values
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Round2Decimals(System.Decimal,System.Decimal)">
            <summary>
            round number to nearest decimal places (eg MINTICK)
            </summary>
            <param name="num"></param>
            <param name="round2nearest"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.OpenPT(System.Decimal,System.Decimal,System.Int32)">
            <summary>
            Gets the open PL on a per-share basis, ignoring the size of the position.
            </summary>
            <param name="LastTrade">The last trade.</param>
            <param name="AvgPrice">The avg price.</param>
            <param name="PosSize">Size of the pos.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.OpenPT(System.Decimal,System.Decimal,System.Boolean)">
            <summary>
            Gets the open PL on a per-share basis (also called points or PT), ignoring the size of the position.
            </summary>
            <param name="LastTrade">The last trade.</param>
            <param name="AvgPrice">The avg price.</param>
            <param name="Side">if set to <c>true</c> [side].</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.OpenPL(System.Decimal,System.Decimal,System.Int32)">
            <summary>
            Gets the open PL considering all the shares held in a position.
            </summary>
            <param name="LastTrade">The last trade.</param>
            <param name="AvgPrice">The avg price.</param>
            <param name="PosSize">Size of the pos.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.OpenPL(System.Decimal,Prac.API.Position)">
            <summary>
            get open pl for position given the last trade
            </summary>
            <param name="LastTrade"></param>
            <param name="Pos"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.taprep(System.Decimal[])">
            <summary>
            prepare an array for us with ta lib
            </summary>
            <param name="ih"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.taprep(System.Decimal[],System.Boolean)">
            <summary>
            prepare an array for us with ta lib
            </summary>
            <param name="ih"></param>
            <param name="includerecent"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.taprep(System.Decimal[],System.Int32@,System.Double[]@)">
            <summary>
            prepare an array for us with ta lib
            </summary>
            <param name="ih"></param>
            <param name="end"></param>
            <param name="h"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.taprep(System.Decimal[],System.Boolean,System.Int32@,System.Double[]@)">
            <summary>
            prepare an array for us with ta lib
            </summary>
            <param name="ih"></param>
            <param name="includerecent"></param>
            <param name="end"></param>
            <param name="h"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.taprep(System.Int64[])">
            <summary>
            prepare an array for us with ta lib
            </summary>
            <param name="ih"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.taprep(System.Int64[],System.Boolean)">
            <summary>
            prepare an array for us with ta lib
            </summary>
            <param name="ih"></param>
            <param name="includerecent"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.taprep(System.Int64[],System.Int32@,System.Double[]@)">
            <summary>
            prepare an array for us with ta lib
            </summary>
            <param name="ih"></param>
            <param name="end"></param>
            <param name="h"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.taprep(System.Int64[],System.Boolean,System.Int32@,System.Double[]@)">
            <summary>
            prepare an array for us with ta lib
            </summary>
            <param name="ih"></param>
            <param name="includerecent"></param>
            <param name="end"></param>
            <param name="h"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.TAPopulateGT(System.String,System.Int32,System.Double[]@,Prac.API.GenericTracker{System.Decimal})">
            <summary>
            populate generic tracker with most recent TA-lib result
            </summary>
            <param name="sym"></param>
            <param name="nb"></param>
            <param name="res"></param>
            <param name="gt"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.TAPopulateGT(System.Int32,System.Int32,System.Double[]@,Prac.API.GenericTracker{System.Decimal})">
            <summary>
            populate generic tracker with most recent TA-lib result
            </summary>
            <param name="idx"></param>
            <param name="nb">number of elements (returned from ta lib)</param>
            <param name="res">result (returned from ta-lib)</param>
            <param name="gt"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.TAPopulateGT(System.Int32,System.Int32,System.Int32,System.Double[]@,Prac.API.GenericTracker{System.Decimal})">
            <summary>
            populate generic tracker with most recent TA-lib result
            </summary>
            <param name="idx"></param>
            <param name="nb">number of elements (returned from ta lib)</param>
            <param name="dplaces">round to this many decimal places</param>
            <param name="res">result (returned from ta-lib)</param>
            <param name="gt"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.TAPopulateGT(System.Int32,System.Int32,System.Int32[]@,Prac.API.GenericTracker{System.Int32})">
            <summary>
            populate a gt with a talib integer result
            </summary>
            <param name="idx"></param>
            <param name="nb"></param>
            <param name="res"></param>
            <param name="gt"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.TAPopulateGT(System.Int32,System.Int32,System.Int32,System.Int32[]@,Prac.API.GenericTracker{System.Int32})">
            <summary>
            populate a gt with a talib integer result
            </summary>
            <param name="idx"></param>
            <param name="nb"></param>
            <param name="dplaces"></param>
            <param name="res"></param>
            <param name="gt"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Double2Decimal_ref(System.Double[]@)">
            <summary>
            convert double array to decimal
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Double2Decimal(System.Double[])">
            <summary>
            convert double array to decimal
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.ClosePT(Prac.API.Position,Prac.API.Trade)">
            <summary>
            Gets the closed PL on a per-share basis, ignoring how many shares are held.
            </summary>
            <param name="existing">The existing position.</param>
            <param name="closing">The portion of the position that's being closed/changed.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.ClosePL(Prac.API.Position,Prac.API.Trade)">
            <summary>
            Gets the closed PL on a position basis, the PL that is registered to the account for the entire shares transacted.
            </summary>
            <param name="existing">The existing position.</param>
            <param name="closing">The portion of the position being changed/closed.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Norm2Min(System.Decimal,System.Int32)">
            <summary>
            round any number to the nearest midsize, with rounding and maintain sign
            </summary>
            <param name="size"></param>
            <param name="MINSIZE"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.OffsetPrice(Prac.API.Position,System.Decimal)">
            <summary>
            Provides an offsetting price from a position.
            </summary>
            <param name="p">Position</param>
            <param name="offset">Offset amount</param>
            <returns>Offset price</returns>
        </member>
        <member name="M:Prac.Core.Calc.Sum(System.Decimal[],System.Int32)">
            <summary>
            sum last elements of array
            </summary>
            <param name="array"></param>
            <param name="barsback"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Sum(System.Decimal[],System.Int32,System.Int32)">
            <summary>
            sum part of an array
            </summary>
            <param name="array"></param>
            <param name="startindex"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Sum(System.Decimal[])">
            <summary>
            gets sum of entire array
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.SumSquares(System.Decimal[],System.Int32)">
            <summary>
            gets sum of squares for end of an array
            </summary>
            <param name="array"></param>
            <param name="barsback"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.SumSquares(System.Decimal[],System.Int32,System.Int32)">
            <summary>
            get sums of squares for part of an array
            </summary>
            <param name="array"></param>
            <param name="startindex"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.SumSquares(System.Decimal[])">
            <summary>
            gets sum of squares for entire array
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Sum(System.Int32[],System.Int32)">
            <summary>
            sum last elements of array
            </summary>
            <param name="array"></param>
            <param name="barsback"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Sum(System.Int32[],System.Int32,System.Int32)">
            <summary>
            sum part of an array
            </summary>
            <param name="array"></param>
            <param name="startindex"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Sum(System.Int64[],System.Int32,System.Int32)">
            <summary>
            sum part of an array
            </summary>
            <param name="array"></param>
            <param name="startindex"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Sum(System.Int64[])">
            <summary>
            gets sum of entire array
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Sum(System.Int32[])">
            <summary>
            gets sum of entire array
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.SumSquares(System.Int32[],System.Int32)">
            <summary>
            gets sum of squares for end of an array
            </summary>
            <param name="array"></param>
            <param name="barsback"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.SumSquares(System.Int32[],System.Int32,System.Int32)">
            <summary>
            get sums of squares for part of an array
            </summary>
            <param name="array"></param>
            <param name="startindex"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.SumSquares(System.Int64[],System.Int32,System.Int32)">
            <summary>
            get sums of squares for part of an array
            </summary>
            <param name="array"></param>
            <param name="startindex"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.SumSquares(System.Int32[])">
            <summary>
            gets sum of squares for entire array
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.SumSquares(System.Int64[])">
            <summary>
            gets sum of squares for entire array
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Avg(System.Decimal[])">
            <summary>
            gets mean of an array
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Avg(System.Decimal[],System.Boolean)">
            <summary>
            gets mean of an array
            </summary>
            <param name="array"></param>
            <param name="returnzeroIfempty"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Avg(System.Double[])">
            <summary>
            gets mean of an array
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Avg(System.Double[],System.Boolean)">
            <summary>
            gets mean of an array
            </summary>
            <param name="array"></param>
            <param name="returnzeroIfempty"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Add(System.Int32[],System.Int32[])">
            <summary>
            adds two arrays
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.AddBig(System.Int32[],System.Int32[])">
            <summary>
            adds two arrays
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Add(System.Decimal[],System.Decimal[])">
            <summary>
            adds two arrays
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Subtract(System.Int32[],System.Int32[])">
            <summary>
            subtracts 2nd array from first array
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Subtract(System.Int64[],System.Int64[])">
            <summary>
            subtracts 2nd array from first array
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Subtract(System.Decimal[],System.Decimal[])">
            <summary>
            subtracts 2nd array from first array
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Product(System.Int32[],System.Int32[])">
            <summary>
            multiplies two arrays
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.ProductBig(System.Int32[],System.Int32[])">
            <summary>
            multiplies two arrays
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.ProductBig(System.Int64[],System.Int64[])">
            <summary>
            multiplies two arrays
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Product(System.Decimal[],System.Decimal[])">
            <summary>
            multiplies two arrays
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Sum(System.Double[],System.Int32)">
            <summary>
            sum last elements of array
            </summary>
            <param name="array"></param>
            <param name="barsback"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Sum(System.Double[],System.Int32,System.Int32)">
            <summary>
            sum part of an array
            </summary>
            <param name="array"></param>
            <param name="startindex"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Sum(System.Double[])">
            <summary>
            gets sum of entire array
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.SumSquares(System.Double[],System.Int32)">
            <summary>
            gets sum of squares for end of an array
            </summary>
            <param name="array"></param>
            <param name="barsback"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.SumSquares(System.Double[],System.Int32,System.Int32)">
            <summary>
            get sums of squares for part of an array
            </summary>
            <param name="array"></param>
            <param name="startindex"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.SumSquares(System.Double[])">
            <summary>
            gets sum of squares for entire array
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Add(System.Double[],System.Double[])">
            <summary>
            adds two arrays
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Subtract(System.Double[],System.Double[])">
            <summary>
            subtracts 2nd array from first array
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Product(System.Double[],System.Double[])">
            <summary>
            multiplies two arrays
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Divide2Double(System.Int32[],System.Int32[])">
            <summary>
            divides first array by second array.  
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Divide2Double(System.Int64[],System.Int64[])">
            <summary>
            divides first array by second array.  
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Divide(System.Double[],System.Double[])">
            <summary>
            divides first array by second array.  
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Add(System.Int32[],System.Double)">
            <summary>
            adds a constant to an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Add(System.Int64[],System.Double)">
            <summary>
            adds a constant to an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Divide(System.Int32[],System.Int32[])">
            <summary>
            divides first array by second array.  
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Divide(System.Int64[],System.Int64[])">
            <summary>
            divides first array by second array.  
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Divide(System.Decimal[],System.Decimal[])">
            <summary>
            divides first array by second array.  
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Add(System.Int32[],System.Decimal)">
            <summary>
            adds a constant to an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Add(System.Int64[],System.Decimal)">
            <summary>
            adds a constant to an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Add(System.Int64[],System.Int64)">
            <summary>
            adds a constant to an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Subtract(System.Int32[],System.Decimal)">
            <summary>
            subtracts constant from an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Subtract(System.Int64[],System.Decimal)">
            <summary>
            subtracts constant from an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Subtract(System.Int32[],System.Double)">
            <summary>
            subtracts constant from an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Subtract(System.Int64[],System.Double)">
            <summary>
            subtracts constant from an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Subtract(System.Int32[],System.Int32)">
            <summary>
            subtracts constant from an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Subtract(System.Int64[],System.Int64)">
            <summary>
            subtracts constant from an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Subtract(System.Decimal[],System.Decimal)">
            <summary>
            subtracts constant from an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Product(System.Int32[],System.Double)">
            <summary>
            takes product of constant and an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Product(System.Double[],System.Double)">
            <summary>
            takes product of constant and an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Product(System.Int64[],System.Double)">
            <summary>
            takes product of constant and an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Product(System.Int32[],System.Decimal)">
            <summary>
            takes product of constant and an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Product(System.Int64[],System.Decimal)">
            <summary>
            takes product of constant and an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Product(System.Int32[],System.Int32)">
            <summary>
            takes product of constant and an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Product(System.Int64[],System.Int64)">
            <summary>
            takes product of constant and an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Product(System.Decimal[],System.Decimal)">
            <summary>
            takes product of constant and an array
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Divide(System.Int32[],System.Decimal)">
            <summary>
            divides array by a constant
            </summary>
            <param name="array"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.StdDev(System.Int32[])">
            <summary>
            gets standard deviation for values of a population
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.StdDev(System.Int64[])">
            <summary>
            gets standard deviation for values of a population
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.StdDevSam(System.Int32[])">
            <summary>
            gets standard deviation for values of a sample
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.StdDevSam(System.Int64[])">
            <summary>
            gets standard deviation for values of a sample
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.EndSlice(System.Double[],System.Int32)">
            <summary>
            Takes slice of last N elements of an array
            </summary>
            <param name="inputarray"></param>
            <param name="lastNumElements"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Slice(System.Double[],System.Int32)">
            <summary>
            takes slice of first N elements of array
            </summary>
            <param name="input"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Slice(System.Double[],System.Int32,System.Int32)">
            <summary>
            takes slice of any N elements of array
            </summary>
            <param name="input"></param>
            <param name="start"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.EndSlice(System.Decimal[],System.Int32)">
            <summary>
            Takes slice of last N elements of an array
            </summary>
            <param name="inputarray"></param>
            <param name="lastNumElements"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Slice(System.Int64[],System.Int32)">
            <summary>
            takes slice of first N elements of array
            </summary>
            <param name="a"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Slice(System.Int64[],System.Int32,System.Int32)">
            <summary>
            takes slice of some N elements of array
            </summary>
            <param name="a"></param>
            <param name="start"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Slice(System.Int32[],System.Int32)">
            <summary>
            takes slice of first N elements of array
            </summary>
            <param name="input"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Slice(System.Int32[],System.Int32,System.Int32)">
            <summary>
            takes slice of any N elements of array
            </summary>
            <param name="input"></param>
            <param name="start"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Slice(System.Decimal[],System.Int32)">
            <summary>
            takes slice of first N elements of array
            </summary>
            <param name="input"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Slice(System.Decimal[],System.Int32,System.Int32)">
            <summary>
            takes slice of any N elements of array
            </summary>
            <param name="input"></param>
            <param name="start"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.EndSlice(System.Int32[],System.Int32)">
            <summary>
            Takes slice of last N elements of an array
            </summary>
            <param name="inputarray"></param>
            <param name="lastNumElements"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.EndSlice(System.Int64[],System.Int32)">
            <summary>
            Takes slice of last N elements of an array
            </summary>
            <param name="inputarray"></param>
            <param name="lastNumElements"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Date(System.Int32)">
            <summary>
            Returns a bardate as an array of ints in the form [year,month,day]
            </summary>
            <param name="bardate">The bardate.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.RateOfReturn(System.Double[],System.Double[])">
            <summary>
            calculate a percentage return based upon a given amount of money used and the absolute return for this money, for each respective securtiy in a portfolio.
            </summary>
            <param name="MoneyInUse"></param>
            <param name="AbsoluteReturn"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Max(System.Double[])">
            <summary>
            gets maximum in an array (will return MaxValue if array has no elements)
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.LL(System.Double[])">
            <summary>
            lowest low of array
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.HH(Prac.API.BarList,System.Int32)">
            <summary>
            Returns the highest-high of the barlist, for so many bars back.
            </summary>
            <param name="b">The barlist.</param>
            <param name="barsback">The barsback to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.HH(System.Decimal[])">
            <summary>
            highest high of array
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.LL(System.Decimal[])">
            <summary>
            lowest low of array
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.HH(Prac.API.BarList)">
            <summary>
            Returns the highest high for the entire barlist.
            </summary>
            <param name="b">The b.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.LL(Prac.API.BarList,System.Int32)">
            <summary>
            The lowest low for the barlist, considering so many bars back.
            </summary>
            <param name="b">The barlist.</param>
            <param name="barsback">The barsback to consider.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.LL(Prac.API.BarList)">
            <summary>
            Lowest low for the entire barlist.
            </summary>
            <param name="b">The barlist.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Min(System.Decimal[])">
            <summary>
            gets minum of an array (will return MinValue if array has no elements)
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Min(System.Int32[])">
            <summary>
            gets minimum of an array (will return MinValue if array has no elements)
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Min(System.Int64[])">
            <summary>
            gets minimum of an array (will return MinValue if array has no elements)
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Max(System.Decimal[])">
            <summary>
            gets maximum in an array (will return MaxValue if array has no elements)
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Max(System.Int32[])">
            <summary>
            gets maximum in an array (will return MaxValue if array has no elements)
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Max(System.Int64[])">
            <summary>
            gets maximum in an array (will return MaxValue if array has no elements)
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Highs(Prac.API.BarList,System.Int32)">
            <summary>
            gets most recent number of highs from a barlist
            </summary>
            <param name="chart"></param>
            <param name="bars"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Lows(Prac.API.BarList,System.Int32)">
            <summary>
            gets most recent lows from barlist, for certain number of bars
            (default is entire list)
            </summary>
            <param name="chart"></param>
            <param name="bars"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Lows(Prac.API.BarList)">
            <summary>
            gets ALL lows from barlist, at default bar interval
            </summary>
            <param name="chart"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Opens(Prac.API.BarList,System.Int32)">
            <summary>
            gets opening prices for most recent bars, at default bar interval
            </summary>
            <param name="chart"></param>
            <param name="bars"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Opens(Prac.API.BarList)">
            <summary>
            gets opening prices for ALL bars, at the default bar interval
            </summary>
            <param name="chart"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Closes(Prac.API.BarList,System.Int32)">
            <summary>
            gets the most recent closing prices for a certain number of bars
            </summary>
            <param name="chart"></param>
            <param name="bars"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Closes(Prac.API.BarList)">
            <summary>
            gets most recent closing prices for ALL bars, default bar interval
            </summary>
            <param name="chart"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Volumes(Prac.API.BarList,System.Int32)">
            <summary>
            gets the most recent volumes from a barlist, given a certain number of bars back
            </summary>
            <param name="chart"></param>
            <param name="bars"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Volumes(Prac.API.BarList)">
            <summary>
            gets volumes for ALL bars, with default bar interval
            </summary>
            <param name="chart"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.HLRange(Prac.API.BarList)">
            <summary>
            gets the high to low range of a barlist, for the default interval
            </summary>
            <param name="chart"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.CORange(Prac.API.BarList)">
            <summary>
            gets array of close to open ranges for default interval of a barlist
            </summary>
            <param name="chart"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.TrueRange(Prac.API.BarList)">
            <summary>
            gets an array of true range values representing each bar in chart
            (uses default bar interval)
            </summary>
            <param name="chart"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.FetchCharts(System.String[])">
            <summary>
            downloads yearly charts for a list of symbols
            (source: google finance)
            </summary>
            <param name="symbols"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.BollingerUpper(Prac.API.BarList)">
            <summary>
            calculates upper bollinger using default # stdev of 2.5 and opening prices.
            Note, for speed it's faster to calculate these yourself.
            </summary>
            <param name="bl"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.BollingerLower(Prac.API.BarList)">
            <summary>
            calculates lower bollinger using default # stdev of 2.5 and opening prices.
            Note, for speed it's faster to calculate these yourself.
            </summary>
            <param name="bl"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.BollingerLower(Prac.API.BarList,System.Decimal)">
            <summary>
            calculates lower bollinger using opening prices.  calculate yourself for faster speed
            </summary>
            <param name="bl"></param>
            <param name="numStdDevs"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.BollingerLower(Prac.API.BarList,System.Decimal,System.Boolean)">
            <summary>
            calculates lower bollinger using open (true) or closing (false) prices, at specified # of standard deviations
            </summary>
            <param name="bl"></param>
            <param name="numStdDevs"></param>
            <param name="useOpens"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.SharpeRatio(System.Decimal,System.Decimal,System.Decimal)">
            <summary>
            computes sharpe ratio for a constant rate of risk free returns, give portfolio rate of return and portfolio volatility
            </summary>
            <param name="ratereturn"></param>
            <param name="stdevRate"></param>
            <param name="riskFreeRate"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.SortinoRatio(System.Decimal,System.Decimal,System.Decimal)">
            <summary>
            computes sortinio ratio for constant rate of risk free return, give portfolio rate of return and downside volatility
            </summary>
            <param name="ratereturn"></param>
            <param name="stdevRateDownside"></param>
            <param name="riskFreeRate"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.PositionCost(Prac.API.Position)">
            <summary>
            computes cost of a current position without taking into account side of position
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.PositionCost(Prac.API.Position,System.Boolean)">
            <summary>
            computes cost of current position without taking into account side
            </summary>
            <param name="p"></param>
            <param name="absolutecost"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.MoneyInUse(Prac.Core.PositionTracker)">
            <summary>
            computes money used to purchase a portfolio of positions.
            uses average price for position.
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.RateOfReturn(System.Decimal[],System.Decimal[])">
            <summary>
            calculate a percentage return based upon a given amount of money used and the absolute return for this money, for each respective securtiy in a portfolio.
            </summary>
            <param name="MoneyInUse"></param>
            <param name="AbsoluteReturn"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.AbsoluteReturn(Prac.Core.PositionTracker,System.Decimal[],System.Boolean,System.Boolean)">
            <summary>
            gets absolute return of portfolio of positions at closing or market prices, or both
            </summary>
            <param name="pt"></param>
            <param name="marketprices"></param>
            <param name="countClosedPL"></param>
            <param name="countOpenPL"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.AbsoluteReturn(Prac.Core.PositionTracker)">
            <summary>
            calculate absolute return only for closed portions of positions
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.AbsoluteReturn(Prac.Core.PositionTracker,Prac.API.GenericTracker{System.Decimal},System.Boolean)">
            <summary>
            returns absolute return of all positions in order they are listed in position tracker
            both closed and open pl may be included
            </summary>
            <param name="pt"></param>
            <param name="marketprices"></param>
            <param name="countClosedPL"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.MaxDDVal(System.Decimal[])">
            <summary>
            calculate maximum drawdown from a PL stream for a given security/portfolio as a dollar value
            </summary>
            <param name="ret">array containing pl values for portfolio or security</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.MaxDDPct(System.Collections.Generic.List{Prac.API.Trade})">
            <summary>
            maximum drawdown as a percentage
            </summary>
            <param name="fills"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Decimal2Double_ref(System.Decimal[]@)">
            <summary>
            convert an array of decimals to less precise doubles
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Decimal2Double(System.Decimal[])">
            <summary>
            convert an array of decimals to less precise doubles
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.Decimal2Double(System.Decimal[],System.Double[]@)">
            <summary>
            convert an array of decimals to less precise doubles
            </summary>
            <param name="array"></param>
            <param name="vals"></param>
        </member>
        <member name="M:Prac.Core.Calc.Decimal2Double_ref(System.Decimal[]@,System.Double[]@)">
            <summary>
            convert an array of decimals to less precise doubles
            </summary>
            <param name="array"></param>
            <param name="vals"></param>
        </member>
        <member name="M:Prac.Core.Calc.parray(System.Double[])">
            <summary>
            print an array
            </summary>
            <param name="prices"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.parray(System.Double[],System.Int32)">
            <summary>
            print an array
            </summary>
            <param name="prices"></param>
            <param name="back"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.parray(System.Decimal[])">
            <summary>
            print an array
            </summary>
            <param name="prices"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.parray(System.Decimal[],System.Int32)">
            <summary>
            print an array
            </summary>
            <param name="prices"></param>
            <param name="back"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.parray(System.Int32[],System.Int32)">
            <summary>
            print an array
            </summary>
            <param name="prices"></param>
            <param name="back"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.fillarray(System.Decimal,System.Int32)">
            <summary>
            fill an array with a value
            </summary>
            <param name="val"></param>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.Calc.fillarray(System.Int32,System.Int32)">
            <summary>
            fill an array with a value
            </summary>
            <param name="val"></param>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="T:Prac.Core.PapertradeTracker">
            <summary>
            route your orders through this component to paper trade with a live data feed
            </summary>
        </member>
        <member name="M:Prac.Core.PapertradeTracker.newTick(Prac.API.Tick)">
            <summary>
            pass data feed through to use for fills
            </summary>
            <param name="k"></param>
        </member>
        <member name="M:Prac.Core.PapertradeTracker.sendorder(Prac.API.Order)">
            <summary>
            send paper trade orders
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:Prac.Core.PapertradeTracker.sendcancel(System.Int64)">
            <summary>
            cancel papertrade orders
            </summary>
            <param name="id"></param>
        </member>
        <member name="P:Prac.Core.PapertradeTracker.UseBidAskFills">
            <summary>
            whether to use bid ask for fills, otherwise last is used.
            </summary>
        </member>
        <member name="E:Prac.Core.PapertradeTracker.GotFillEvent">
            <summary>
            fill acknowledged, order filled.
            </summary>
        </member>
        <member name="E:Prac.Core.PapertradeTracker.GotOrderEvent">
            <summary>
            order acknowledgement, order placed.
            </summary>
        </member>
        <member name="E:Prac.Core.PapertradeTracker.GotCancelEvent">
            <summary>
            cancel acknowledgement, order is canceled
            </summary>
        </member>
        <member name="E:Prac.Core.PapertradeTracker.SendCancelEvent">
            <summary>
            copy of the cancel request
            </summary>
        </member>
        <member name="E:Prac.Core.PapertradeTracker.SendDebugEvent">
            <summary>
            debug messages
            </summary>
        </member>
        <member name="P:Prac.Core.PapertradeTracker.QueuedOrders">
            <summary>
            gets currently queued orders
            </summary>
        </member>
        <member name="P:Prac.Core.PapertradeTracker.QueuedCancelCount">
            <summary>
            gets count of queued cancels
            </summary>
        </member>
        <member name="T:Prac.Core.GauntletEngine">
            <summary>
            lightweight backtesting (data + sim)
            </summary>
        </member>
        <member name="T:Prac.Core.Email">
            <summary>
            send email 
            </summary>
        </member>
        <member name="M:Prac.Core.Email.Send(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Sends the specified email.
            </summary>
            <param name="to">To address.</param>
            <param name="from">From address.</param>
            <param name="subject">The subject.</param>
            <param name="message">The message.</param>
        </member>
        <member name="T:Prac.Core.RingBuffer`1">
            <summary>
            Circular buffer.   Allows reading and writing of up to BufferSize 
            element count in a FIFO fashion.   Useful for passing data asynchronously 
            between threads without requiring locking.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Prac.Core.RingBuffer`1.Write(`0)">
            <summary>
            writes a value into the buffer
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:Prac.Core.RingBuffer`1.Read">
            <summary>
            reads next unread element from buffer
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.RingBuffer`1.#ctor(System.Int32)">
            <summary>
            create a buffer of fixed size in elements
            </summary>
            <param name="BufferSize"></param>
        </member>
        <member name="E:Prac.Core.RingBuffer`1.BufferOverrunEvent">
            <summary>
            called when buffer overrun occurs
            </summary>
        </member>
        <member name="P:Prac.Core.RingBuffer`1.BufferOverrun">
            <summary>
            number of overruns, should be zero (otherwise increase buffer size)
            </summary>
        </member>
        <member name="P:Prac.Core.RingBuffer`1.BufferSize">
            <summary>
            maximum # of unread elements the buffer can hold.
            </summary>
        </member>
        <member name="P:Prac.Core.RingBuffer`1.Count">
            <summary>
            Count of unread elements
            </summary>
        </member>
        <member name="P:Prac.Core.RingBuffer`1.isEmpty">
            <summary>
            returns true if all written elements have been read from buffer
            </summary>
        </member>
        <member name="P:Prac.Core.RingBuffer`1.hasItems">
            <summary>
            returns false if there is more to be read
            </summary>
        </member>
        <member name="T:Prac.Core.ResponseLoader">
            <summary>
            used for loading responses from disk (via DLL) or from already loaded assemblies.
            </summary>
        </member>
        <member name="M:Prac.Core.ResponseLoader.FromDLL(System.String,System.String,Prac.API.DebugDelegate)">
            <summary>
            Create a single Response from a DLL containing many Responses.  
            </summary>
            <param name="fullname"></param>
            <param name="dllname"></param>
            <param name="deb"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.ResponseLoader.FromDLL(System.String,System.String)">
            <summary>
            Create a single Response from a DLL containing many Responses.  
            </summary>
            <param name="fullname">The fully-qualified Response Name (as in 'BoxExamples.Name').  </param>
            <param name="dllname">The path and filename of DLL.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.ResponseLoader.FromAssembly(System.Reflection.Assembly,System.String)">
            <summary>
            Create a single Response from an Assembly containing many Responses. 
            </summary>
            <param name="a"></param>
            <param name="fullname"></param>
            <param name="deb"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.ResponseLoader.FromAssembly(System.Reflection.Assembly,System.String,Prac.API.DebugDelegate)">
            <summary>
            Create a single Response from an Assembly containing many Responses. 
            </summary>
            <param name="a">the assembly object</param>
            <param name="boxname">The fully-qualified Response Name (as in Response.FullName).</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.ResponseLoader.GetResponseList(System.String)">
            <summary>
            Gets full Response names found in a given file.
            </summary>
            <param name="boxdll">The file path of the assembly containing the boxes.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.ResponseLoader.GetResponseList(System.Reflection.Assembly)">
            <summary>
            Gets all Response names found in a given assembly.  Names are FullNames, which means namespace.FullName.  eg 'BoxExamples.BigTradeUI'
            </summary>
            <param name="boxdll">The assembly.</param>
            <returns>list of response names</returns>
        </member>
        <member name="T:Prac.Core.InvalidResponse">
            <summary>
            used to signify a response was invalid, an incompatible version or otherwise unloadable.
            </summary>
        </member>
        <member name="T:Prac.Core.YahooQuickQuote">
            <summary>
            obtain a realtime quote from yahoo.
            (take caution not to overuse this.  yahoo will rate limit you.)
            </summary>
        </member>
        <member name="F:Prac.Core.YahooQuickQuote.baseurl">
            <summary>
            base url for service
            </summary>
        </member>
        <member name="M:Prac.Core.YahooQuickQuote.Fetch(System.String)">
            <summary>
            fetch a quick quote from the yahoo service. returns a quick quote object.
            </summary>
            <param name="sym"></param>
            <returns></returns>
        </member>
        <member name="T:Prac.Core.CrashDumpFile">
            <summary>
            quick crash dump files
            </summary>
        </member>
        <member name="M:Prac.Core.CrashDumpFile.make_local(System.String)">
            <summary>
            set the local program value
            </summary>
            <param name="program"></param>
        </member>
        <member name="M:Prac.Core.CrashDumpFile.make_local(System.Object,System.Threading.ThreadExceptionEventArgs)">
            <summary>
            make a crash dump file on local system
            </summary>
            <param name="program"></param>
            <param name="uex"></param>
        </member>
        <member name="M:Prac.Core.CrashDumpFile.make_local(System.Object,System.UnhandledExceptionEventArgs)">
            <summary>
            make a crash dump file on local system
            </summary>
            <param name="program"></param>
            <param name="uex"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.CrashDumpFile.make_local(System.Exception)">
            <summary>
            make a crash dump file on local system
            </summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.CrashDumpFile.make_local(System.String,System.Exception)">
            <summary>
            make a crash dump file on local system
            </summary>
            <param name="program"></param>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.CrashDumpFile.LOCAL_PROGRAM">
            <summary>
            get or set the local program value
            </summary>
        </member>
        <member name="T:Prac.Core.MultiSimImpl">
            <summary>
            historical simulation component.
            plays back many tickfiles insequence over time.
            also processes orders and executions against same tickfiles (via embedded Broker component).
            </summary>
        </member>
        <member name="M:Prac.Core.MultiSimImpl.#ctor">
            <summary>
            Create a historical simulator using default tick folder and null filter
            </summary>
        </member>
        <member name="M:Prac.Core.MultiSimImpl.#ctor(System.String)">
            <summary>
            Create historical simulator with your own tick folder
            </summary>
            <param name="TickFolder"></param>
        </member>
        <member name="M:Prac.Core.MultiSimImpl.#ctor(Prac.Core.TickFileFilter)">
            <summary>
            Create a historical simulator
            </summary>
            <param name="tff"></param>
        </member>
        <member name="M:Prac.Core.MultiSimImpl.#ctor(System.String,Prac.Core.TickFileFilter)">
            <summary>
            Create a historical simulator
            </summary>
            <param name="TickFolder">tick folder to use</param>
            <param name="tff">filter to determine what tick files from folder to use</param>
        </member>
        <member name="M:Prac.Core.MultiSimImpl.#ctor(System.String[])">
            <summary>
            Create a historical simulator
            </summary>
            <param name="filenames">list of tick files to use</param>
        </member>
        <member name="M:Prac.Core.MultiSimImpl.Reset">
            <summary>
            Reset the simulation
            </summary>
        </member>
        <member name="M:Prac.Core.MultiSimImpl.Initialize">
            <summary>
            Reinitialize the cache
            </summary>
        </member>
        <member name="M:Prac.Core.MultiSimImpl.PlayTo(System.Int64)">
            <summary>
            Run simulation to specific time
            </summary>
            <param name="time">Simulation will run until this time (use HistSim.ENDSIM for last time)</param>
        </member>
        <member name="M:Prac.Core.MultiSimImpl.Stop">
            <summary>
            stops any running simulation and closes all data files
            </summary>
        </member>
        <member name="P:Prac.Core.MultiSimImpl.TicksPresent">
            <summary>
            Total ticks available for processing, based on provided filter or tick files.
            </summary>
        </member>
        <member name="P:Prac.Core.MultiSimImpl.TicksProcessed">
            <summary>
            Ticks processed in this simulation run.
            </summary>
        </member>
        <member name="P:Prac.Core.MultiSimImpl.FillCount">
            <summary>
            Fills executed during this simulation run.
            </summary>
        </member>
        <member name="P:Prac.Core.MultiSimImpl.NextTickTime">
            <summary>
            Gets next tick in the simulation
            </summary>
        </member>
        <member name="P:Prac.Core.MultiSimImpl.Folder">
            <summary>
            change the tickfolder histsim scans for historical data
            </summary>
        </member>
        <member name="P:Prac.Core.MultiSimImpl.CacheWait">
            <summary>
            milliseconds to wait between starting I/O threads and trying to access data.
            is used only on multi processor machines.
            </summary>
        </member>
        <member name="T:Prac.Core.GTColorHelper">
            <summary>
            for consistent auto-coloring of indicators
            </summary>
        </member>
        <member name="T:Prac.Core.WinUtil">
            <summary>
            windows-centric utility functions
            </summary>
        </member>
        <member name="M:Prac.Core.WinUtil.CoreVersion">
            <summary>
            Gets string representing the version of this suite.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.WinUtil.CoreIdentity">
            <summary>
            Gets a string representing the identity of this suite.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.WinUtil.ProgramBuild(System.String)">
            <summary>
            gets build for specific installed program.
            returns 0 if not installed or error.
            </summary>
            <param name="program"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.WinUtil.ProgramBuild(System.String,Prac.API.DebugDelegate)">
            <summary>
            get build with debugging information on errors
            </summary>
            <param name="program"></param>
            <param name="deb"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.WinUtil.ProgramPath(System.String)">
            <summary>
            gets folder where a given program is installed
            </summary>
            <param name="PROGRAM"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.WinUtil.ProgramPath(System.String,Prac.API.DebugDelegate)">
            <summary>
            gets folder where given program was installed and provides debugging information
            </summary>
            <param name="PROGRAM"></param>
            <param name="deb"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.WinUtil.TrackUsage">
            <summary>
            determines whether user has consented to application tracking for given program
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.WinUtil.TrackUsage(System.String)">
            <summary>
            determines whether user has consented to application tracking for given program
            </summary>
            <param name="program"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.WinUtil.CoreBuild">
            <summary>
            get build for installed core
            </summary>
            <returns></returns>
        </member>
        <member name="P:Prac.Core.WinUtil.CoreTickDir">
            <summary>
            path to core tick folder
            </summary>
        </member>
        <member name="T:Prac.Core.RandomSymbol">
            <summary>
            used for generating random symbol names in studies.
            (eg if you want to randomly walk the security space)
            Whenever 'seed' is specified, use a randomized value... eg
            (int)DateTime.Now.Ticks or likewise
            </summary>
        </member>
        <member name="M:Prac.Core.RandomSymbol.GetSymbol(System.Int32)">
            <summary>
            gets a single random symbol.
            </summary>
            <param name="seed"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.RandomSymbol.GetSymbol(System.Int32,System.Int32)">
            <summary>
            gets a single random symbol with a specified maximum length
            </summary>
            <param name="seed"></param>
            <param name="maxlength"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.RandomSymbol.Alphacodes2string(System.Int32[])">
            <summary>
            convert a list of ASCII integers to corresponding string
            </summary>
            <param name="codes"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.RandomSymbol.BaseTenConvert(System.Int64,System.Int32)">
            <summary>
            convert from base ten to another number system
            </summary>
            <param name="num"></param>
            <param name="destbase"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.RandomSymbol.GetSymbols(System.Int32)">
            <summary>
            get a random list of symbols of a random length, given seed. (eg (int)DateTime.Now.Ticks
            </summary>
            <param name="seed"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.RandomSymbol.GetSymbols(System.Int32,System.Int32,System.Int32)">
            <summary>
            get a random list of symbols, given seed, maximum symbol length and desired number of symbols. (seed eg (int)DateTime.Now.Ticks
            </summary>
            <param name="seed"></param>
            <param name="symlength"></param>
            <param name="symbolcount"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.RandomSymbol.GetSymbols(System.Int32,System.Int32)">
            <summary>
            get random list of symbols of specified max length
            </summary>
            <param name="symlen"></param>
            <param name="symcount"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.RandomSymbol.GetSymbols">
            <summary>
            get random symbol
            </summary>
            <returns></returns>
        </member>
        <member name="T:Prac.Core.MultiSimPoolImpl">
            <summary>
            historical simulation component.
            plays back many tickfiles insequence over time.
            also processes orders and executions against same tickfiles (via embedded Broker component).
            </summary>
        </member>
        <member name="M:Prac.Core.MultiSimPoolImpl.#ctor">
            <summary>
            Create a historical simulator using default tick folder and null filter
            </summary>
        </member>
        <member name="M:Prac.Core.MultiSimPoolImpl.#ctor(System.String)">
            <summary>
            Create historical simulator with your own tick folder
            </summary>
            <param name="TickFolder"></param>
        </member>
        <member name="M:Prac.Core.MultiSimPoolImpl.#ctor(Prac.Core.TickFileFilter)">
            <summary>
            Create a historical simulator
            </summary>
            <param name="tff"></param>
        </member>
        <member name="M:Prac.Core.MultiSimPoolImpl.#ctor(System.String,Prac.Core.TickFileFilter)">
            <summary>
            Create a historical simulator
            </summary>
            <param name="TickFolder">tick folder to use</param>
            <param name="tff">filter to determine what tick files from folder to use</param>
        </member>
        <member name="M:Prac.Core.MultiSimPoolImpl.#ctor(System.String[])">
            <summary>
            Create a historical simulator
            </summary>
            <param name="filenames">list of tick files to use</param>
        </member>
        <member name="M:Prac.Core.MultiSimPoolImpl.Reset">
            <summary>
            Reset the simulation
            </summary>
        </member>
        <member name="M:Prac.Core.MultiSimPoolImpl.Initialize">
            <summary>
            Reinitialize the cache
            </summary>
        </member>
        <member name="M:Prac.Core.MultiSimPoolImpl.PlayTo(System.Int64)">
            <summary>
            Run simulation to specific time
            </summary>
            <param name="time">Simulation will run until this time (use HistSim.ENDSIM for last time)</param>
        </member>
        <member name="M:Prac.Core.MultiSimPoolImpl.Stop">
            <summary>
            stops any running simulation and closes all data files
            </summary>
        </member>
        <member name="P:Prac.Core.MultiSimPoolImpl.TicksPresent">
            <summary>
            Total ticks available for processing, based on provided filter or tick files.
            </summary>
        </member>
        <member name="P:Prac.Core.MultiSimPoolImpl.TicksProcessed">
            <summary>
            Ticks processed in this simulation run.
            </summary>
        </member>
        <member name="P:Prac.Core.MultiSimPoolImpl.FillCount">
            <summary>
            Fills executed during this simulation run.
            </summary>
        </member>
        <member name="P:Prac.Core.MultiSimPoolImpl.NextTickTime">
            <summary>
            Gets next tick in the simulation
            </summary>
        </member>
        <member name="P:Prac.Core.MultiSimPoolImpl.Folder">
            <summary>
            change the tickfolder histsim scans for historical data
            </summary>
        </member>
        <member name="P:Prac.Core.MultiSimPoolImpl.CacheWait">
            <summary>
            milliseconds to wait between starting I/O threads and trying to access data.
            is used only on multi processor machines.
            </summary>
        </member>
        <member name="T:Prac.Core.AsyncResponse">
            <summary>
            used to provide ultra-fast tick processing on machines with multiple cores.
            takes ticks immediately on main thread, processes them on a seperate thread.
            </summary>
        </member>
        <member name="M:Prac.Core.AsyncResponse.newTick(Prac.API.Tick)">
            <summary>
            pass new ticks through here to be processed asyncrhomously
            </summary>
            <param name="k"></param>
        </member>
        <member name="M:Prac.Core.AsyncResponse.newImbalance(Prac.API.Imbalance)">
            <summary>
            write an imbalance to buffer for later processing
            </summary>
            <param name="imb"></param>
        </member>
        <member name="M:Prac.Core.AsyncResponse.#ctor">
            <summary>
            create an asynchronous responder
            </summary>
        </member>
        <member name="M:Prac.Core.AsyncResponse.#ctor(System.Int32,System.Int32)">
            <summary>
            creates asynchronous responder with specified buffer sizes
            </summary>
            <param name="maxticks"></param>
            <param name="maximb"></param>
        </member>
        <member name="M:Prac.Core.AsyncResponse.Stop">
            <summary>
            stop the read threads and shutdown (call on exit)
            </summary>
        </member>
        <member name="E:Prac.Core.AsyncResponse.GotTick">
            <summary>
            fired when tick is read asychronously from buffer
            </summary>
        </member>
        <member name="E:Prac.Core.AsyncResponse.GotTickQueueEmpty">
            <summary>
             fired when buffer is empty
            </summary>
        </member>
        <member name="E:Prac.Core.AsyncResponse.GotTickQueued">
            <summary>
            fired when buffer is written
            </summary>
        </member>
        <member name="P:Prac.Core.AsyncResponse.TickOverrun">
            <summary>
            should be zero unless buffer too small
            </summary>
        </member>
        <member name="P:Prac.Core.AsyncResponse.SLEEP">
            <summary>
            sleep time in milliseconds between checking read buffer
            </summary>
        </member>
        <member name="E:Prac.Core.AsyncResponse.GotBadTick">
            <summary>
            called if bad tick is written or read.
            check bad counters to see if written or read.
            </summary>
        </member>
        <member name="E:Prac.Core.AsyncResponse.GotBadImbalance">
            <summary>
            called if bad imbalance is written or read.
            check bad counters to see if written or read.
            </summary>
        </member>
        <member name="E:Prac.Core.AsyncResponse.GotTickOverrun">
            <summary>
            called if buffer set is too small
            </summary>
        </member>
        <member name="E:Prac.Core.AsyncResponse.GotImbalanceOverrun">
            <summary>
            called if buffer set is too small
            </summary>
        </member>
        <member name="P:Prac.Core.AsyncResponse.BadTickWritten">
            <summary>
            # of null ticks ignored at write
            </summary>
        </member>
        <member name="P:Prac.Core.AsyncResponse.BadTickRead">
            <summary>
            # of null ticks ignored at read
            </summary>
        </member>
        <member name="P:Prac.Core.AsyncResponse.BadImbalanceWritten">
            <summary>
            # of imbalances ignored at write
            </summary>
        </member>
        <member name="P:Prac.Core.AsyncResponse.BadImbalanceRead">
            <summary>
            # of imbalances ignored at read
            </summary>
        </member>
        <member name="E:Prac.Core.AsyncResponse.GotImbalance">
            <summary>
            fired when imbalance is read asynchronously from buffer
            </summary>
        </member>
        <member name="E:Prac.Core.AsyncResponse.GotImbalanceQueued">
            <summary>
            fired when buffer is written to
            </summary>
        </member>
        <member name="E:Prac.Core.AsyncResponse.GotImbalanceQueueEmpty">
            <summary>
            fired when buffer is empty
            </summary>
        </member>
        <member name="P:Prac.Core.AsyncResponse.ImbalanceOverrun">
            <summary>
            should be zero unless buffer too small
            </summary>
        </member>
        <member name="T:Prac.Core.WMUtil">
            <summary>
            utility class to support windows messaging transport for clients.
            </summary>
        </member>
        <member name="M:Prac.Core.WMUtil.HisHandle(System.String)">
            <summary>
            Gets a handle for a given window name.  Will return InPtr.Zero if no match is found.
            </summary>
            <param name="WindowName">Name of the window.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.WMUtil.SendMsg(System.String,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Sends the MSG.
            </summary>
            <param name="str">The STR.</param>
            <param name="desthandle">The desthandle.</param>
            <param name="sourcehandle">The sourcehandle.</param>
            <param name="type">The type.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.WMUtil.SendMsg(System.String,Prac.API.MessageTypes,System.IntPtr,System.String)">
            <summary>
            Sends the MSG from source window to destination window, using WM_COPYDATA.
            </summary>
            <param name="message">The message.</param>
            <param name="messagetype">The messagetype.</param>
            <param name="destinationwindow">The destinationwindow.</param>
            <returns></returns>
        </member>
        <member name="T:Prac.Core.PCTracker">
            <summary>
            keep track of whether data is arriving for a given client/provider
            </summary>
        </member>
        <member name="F:Prac.Core.PCTracker.DEFAULTPOLLMS">
            <summary>
            default milliseconds between polls (check interval)
            </summary>
        </member>
        <member name="F:Prac.Core.PCTracker.DEFAULTTIMEOUTSEC">
            <summary>
            default seconds for timeout of a given symbol
            </summary>
        </member>
        <member name="M:Prac.Core.PCTracker.#ctor(Prac.API.PracClient)">
            <summary>
            create a tracker for selected provider on client
            </summary>
            <param name="client"></param>
        </member>
        <member name="M:Prac.Core.PCTracker.#ctor(Prac.API.PracClient,Prac.API.Providers)">
            <summary>
            create a tracker for a preferred provider on client
            </summary>
            <param name="client"></param>
            <param name="PreferredBroker"></param>
        </member>
        <member name="M:Prac.Core.PCTracker.#ctor(System.Int32,System.Int32,Prac.API.PracClient,Prac.API.Providers,System.Boolean)">
            <summary>
            create a tracker for preferred provider with custom tick timeout and poll frequency settings
            </summary>
            <param name="pollintervalms"></param>
            <param name="timeoutintervalsec"></param>
            <param name="client"></param>
            <param name="PreferredBroker"></param>
            <param name="connectany"></param>
        </member>
        <member name="M:Prac.Core.PCTracker.Reconnect">
            <summary>
            reconnect/refresh now
            </summary>
        </member>
        <member name="M:Prac.Core.PCTracker.Start">
            <summary>
            start tracker
            </summary>
        </member>
        <member name="M:Prac.Core.PCTracker.Stop">
            <summary>
            stop tracker
            </summary>
        </member>
        <member name="M:Prac.Core.PCTracker.newTick(Prac.API.Tick)">
            <summary>
            call this function from GotTick
            </summary>
            <param name="k"></param>
        </member>
        <member name="E:Prac.Core.PCTracker.GotConnect">
            <summary>
            called when connection is made or refreshed
            </summary>
        </member>
        <member name="E:Prac.Core.PCTracker.GotConnectFail">
            <summary>
            called when no ticks have been received since timeout
            </summary>
        </member>
        <member name="E:Prac.Core.PCTracker.GotDebug">
            <summary>
            contains information useful for debugging
            </summary>
        </member>
        <member name="P:Prac.Core.PCTracker.AlertThreshold">
            <summary>
            # of seconds a symbol (or all symbols for MassAlert) has to stop ticking before alerts are sent
            </summary>
        </member>
        <member name="P:Prac.Core.PCTracker.PollInterval">
            <summary>
            # of MILLIseconds to wait between MassAlert tests
            </summary>
        </member>
        <member name="P:Prac.Core.PCTracker.isConnected">
            <summary>
            provider present connected?
            </summary>
        </member>
        <member name="P:Prac.Core.PCTracker.ReconnectOnlyAfterFirstTick">
            <summary>
            wait for first tick before reconnecting
            </summary>
        </member>
        <member name="T:Prac.Core.PositionImpl">
            <summary>
            A position type used to describe the position in a stock or instrument.
            </summary>
        </member>
        <member name="M:Prac.Core.PositionImpl.op_Implicit(Prac.Core.PositionImpl)~System.Decimal">
            <summary>
            convert from position to decimal (price)
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionImpl.op_Implicit(Prac.Core.PositionImpl)~System.Int32">
            <summary>
            convert from position to integer (size)
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionImpl.op_Implicit(Prac.Core.PositionImpl)~System.Boolean">
            <summary>
            convert from
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionImpl.Adjust(Prac.API.Position)">
            <summary>
            Adjusts the position by applying a new position.
            </summary>
            <param name="pos">The position adjustment to apply.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.PositionImpl.Adjust(Prac.API.Trade)">
            <summary>
            Adjusts the position by applying a new trade or fill.
            </summary>
            <param name="t">The new fill you want this position to reflect.</param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TikUtil.EPF2TIK(System.String[])">
            <summary>
            converts EPF files to tick files in current directory
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Prac.Core.TikUtil.GetFiles">
            <summary>
            finds a group of files with a given extension
            </summary>
            <param name="EXT"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TikUtil.GetFilesFromDate">
            <summary>
            get tick files created today from default folder
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TikUtil.GetFilesFromDate(System.String)">
            <summary>
            get tick files created today
            </summary>
            <param name="tickfolder"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TikUtil.GetFilesFromDate(System.String,System.Int32)">
            <summary>
            get tick files created on a certain date
            </summary>
            <param name="tickfolder"></param>
            <param name="date"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TikUtil.TicksToFile(Prac.API.Tick[])">
            <summary>
            create file from ticks
            </summary>
            <param name="ticks"></param>
        </member>
        <member name="M:Prac.Core.TikUtil.TicksToFile(Prac.API.Tick[],Prac.API.DebugDelegate)">
            <summary>
            create file from ticks
            </summary>
            <param name="ticks"></param>
            <param name="debs"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TikUtil.TicksToFile(Prac.API.Tick[],Prac.API.DebugDelegate,Prac.Core.TikWriter)">
            <summary>
            create file from ticks
            </summary>
            <param name="ticks"></param>
            <param name="debs"></param>
            <param name="tw"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.TikUtil.Barlist2Tick(Prac.API.BarList)">
            <summary>
            create ticks from bars on default interval
            </summary>
            <param name="bl"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.RejectTracker.GotCancel(System.Int64)">
            <summary>
            if cancels are passed through, consider them acks
            </summary>
            <param name="id"></param>
        </member>
        <member name="T:Prac.Core.ThreadHelper">
            <summary>
            system.backgroundworker-less equivalent to SDK runhelper
            </summary>
        </member>
        <member name="T:Prac.Core.OffsetInfo">
            <summary>
            instructions used to control offset amounts and distances.
            </summary>
        </member>
        <member name="M:Prac.Core.OffsetInfo.#ctor(Prac.Core.OffsetInfo)">
            <summary>
            copy an existing offset to this one
            </summary>
            <param name="copy"></param>
        </member>
        <member name="M:Prac.Core.OffsetInfo.#ctor(System.Decimal,System.Decimal,System.Decimal,System.Decimal,System.Boolean,System.Int32)">
            <summary>
            create an offset instruction
            </summary>
            <param name="profitdist">in cents</param>
            <param name="stopdist">in cents</param>
            <param name="profitpercent">in percent (eg .1 = 10%)</param>
            <param name="stoppercent">in percent (eg .1 = 10%)</param>
            <param name="NormalizeSize">true or false</param>
            <param name="MinSize">minimum lot size when normalize size is true</param>
        </member>
        <member name="M:Prac.Core.OffsetInfo.DISABLEOFFSET">
            <summary>
            set an offset to this to disable it
            </summary>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OffsetInfo.PositionProfit(Prac.API.Position,Prac.Core.OffsetInfo)">
            <summary>
            get profit order for given position given offset information
            </summary>
            <param name="p"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:Prac.Core.OffsetInfo.PositionStop(Prac.API.Position,Prac.Core.OffsetInfo)">
            <summary>
            get a stop order for a position given offset information
            </summary>
            <param name="p"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
    </members>
</doc>
